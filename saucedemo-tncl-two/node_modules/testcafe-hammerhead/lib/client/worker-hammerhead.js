// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null)  {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.indexOf('@') === 0 ? path.split('/', 2).join("/") : path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		var localRequire = function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
		if (envRequire) localRequire.fromParentEnvironment = envRequire;
		return localRequire
	};
	return getRequire(modules, [], '');
})
({
	"bowser": {
		":mainpath:": "./src/bowser.js",
		"src": {
			"bowser.js": function (exports, module, require) {
				

				/*!
				 * Bowser - a browser detector
				 * https://github.com/ded/bowser
				 * MIT License | (c) Dustin Diaz 2015
				 */
				!function (root, name, definition) {
				  if (typeof module != 'undefined' && module.exports) module.exports = definition();else if (typeof define == 'function' && define.amd) define(name, definition);else root[name] = definition();
				}(void 0, 'bowser', function () {
				  /**
				    * See useragents.js for examples of navigator.userAgent
				    */
				  var t = true;

				  function detect(ua) {
				    function getFirstMatch(regex) {
				      var match = ua.match(regex);
				      return match && match.length > 1 && match[1] || '';
				    }

				    function getSecondMatch(regex) {
				      var match = ua.match(regex);
				      return match && match.length > 1 && match[2] || '';
				    }

				    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(),
				        likeAndroid = /like android/i.test(ua),
				        android = !likeAndroid && /android/i.test(ua),
				        nexusMobile = /nexus\s*[0-6]\s*/i.test(ua),
				        nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua),
				        chromeos = /CrOS/.test(ua),
				        silk = /silk/i.test(ua),
				        sailfish = /sailfish/i.test(ua),
				        tizen = /tizen/i.test(ua),
				        webos = /(web|hpw)os/i.test(ua),
				        windowsphone = /windows phone/i.test(ua),
				        samsungBrowser = /SamsungBrowser/i.test(ua),
				        windows = !windowsphone && /windows/i.test(ua),
				        mac = !iosdevice && !silk && /macintosh/i.test(ua),
				        linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua),
				        edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i),
				        versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i),
				        tablet = /tablet/i.test(ua),
				        mobile = !tablet && /[^-]mobi/i.test(ua),
				        xbox = /xbox/i.test(ua),
				        result;

				    if (/opera/i.test(ua)) {
				      //  an old Opera
				      result = {
				        name: 'Opera',
				        opera: t,
				        version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
				      };
				    } else if (/opr|opios/i.test(ua)) {
				      // a new Opera
				      result = {
				        name: 'Opera',
				        opera: t,
				        version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
				      };
				    } else if (/SamsungBrowser/i.test(ua)) {
				      result = {
				        name: 'Samsung Internet for Android',
				        samsungBrowser: t,
				        version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
				      };
				    } else if (/coast/i.test(ua)) {
				      result = {
				        name: 'Opera Coast',
				        coast: t,
				        version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
				      };
				    } else if (/yabrowser/i.test(ua)) {
				      result = {
				        name: 'Yandex Browser',
				        yandexbrowser: t,
				        version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
				      };
				    } else if (/ucbrowser/i.test(ua)) {
				      result = {
				        name: 'UC Browser',
				        ucbrowser: t,
				        version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (/mxios/i.test(ua)) {
				      result = {
				        name: 'Maxthon',
				        maxthon: t,
				        version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (/epiphany/i.test(ua)) {
				      result = {
				        name: 'Epiphany',
				        epiphany: t,
				        version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (/puffin/i.test(ua)) {
				      result = {
				        name: 'Puffin',
				        puffin: t,
				        version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
				      };
				    } else if (/sleipnir/i.test(ua)) {
				      result = {
				        name: 'Sleipnir',
				        sleipnir: t,
				        version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (/k-meleon/i.test(ua)) {
				      result = {
				        name: 'K-Meleon',
				        kMeleon: t,
				        version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (windowsphone) {
				      result = {
				        name: 'Windows Phone',
				        windowsphone: t
				      };

				      if (edgeVersion) {
				        result.msedge = t;
				        result.version = edgeVersion;
				      } else {
				        result.msie = t;
				        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
				      }
				    } else if (/msie|trident/i.test(ua)) {
				      result = {
				        name: 'Internet Explorer',
				        msie: t,
				        version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
				      };
				    } else if (chromeos) {
				      result = {
				        name: 'Chrome',
				        chromeos: t,
				        chromeBook: t,
				        chrome: t,
				        version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/chrome.+? edge/i.test(ua)) {
				      result = {
				        name: 'Microsoft Edge',
				        msedge: t,
				        version: edgeVersion
				      };
				    } else if (/vivaldi/i.test(ua)) {
				      result = {
				        name: 'Vivaldi',
				        vivaldi: t,
				        version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
				      };
				    } else if (sailfish) {
				      result = {
				        name: 'Sailfish',
				        sailfish: t,
				        version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/seamonkey\//i.test(ua)) {
				      result = {
				        name: 'SeaMonkey',
				        seamonkey: t,
				        version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/firefox|iceweasel|fxios/i.test(ua)) {
				      result = {
				        name: 'Firefox',
				        firefox: t,
				        version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
				      };

				      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
				        result.firefoxos = t;
				      }
				    } else if (silk) {
				      result = {
				        name: 'Amazon Silk',
				        silk: t,
				        version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/phantom/i.test(ua)) {
				      result = {
				        name: 'PhantomJS',
				        phantom: t,
				        version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/slimerjs/i.test(ua)) {
				      result = {
				        name: 'SlimerJS',
				        slimer: t,
				        version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
				      result = {
				        name: 'BlackBerry',
				        blackberry: t,
				        version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
				      };
				    } else if (webos) {
				      result = {
				        name: 'WebOS',
				        webos: t,
				        version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
				      };
				      /touchpad\//i.test(ua) && (result.touchpad = t);
				    } else if (/bada/i.test(ua)) {
				      result = {
				        name: 'Bada',
				        bada: t,
				        version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
				      };
				    } else if (tizen) {
				      result = {
				        name: 'Tizen',
				        tizen: t,
				        version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
				      };
				    } else if (/qupzilla/i.test(ua)) {
				      result = {
				        name: 'QupZilla',
				        qupzilla: t,
				        version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
				      };
				    } else if (/chromium/i.test(ua)) {
				      result = {
				        name: 'Chromium',
				        chromium: t,
				        version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
				      };
				    } else if (/chrome|crios|crmo/i.test(ua)) {
				      result = {
				        name: 'Chrome',
				        chrome: t,
				        version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
				      };
				    } else if (android) {
				      result = {
				        name: 'Android',
				        version: versionIdentifier
				      };
				    } else if (/safari|applewebkit/i.test(ua)) {
				      result = {
				        name: 'Safari',
				        safari: t
				      };

				      if (versionIdentifier) {
				        result.version = versionIdentifier;
				      }
				    } else if (iosdevice) {
				      result = {
				        name: iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
				      }; // WTF: version is not part of user agent in web apps

				      if (versionIdentifier) {
				        result.version = versionIdentifier;
				      }
				    } else if (/googlebot/i.test(ua)) {
				      result = {
				        name: 'Googlebot',
				        googlebot: t,
				        version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
				      };
				    } else {
				      result = {
				        name: getFirstMatch(/^(.*)\/(.*) /),
				        version: getSecondMatch(/^(.*)\/(.*) /)
				      };
				    } // set webkit or gecko flag for browsers based on these engines


				    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
				      if (/(apple)?webkit\/537\.36/i.test(ua)) {
				        result.name = result.name || "Blink";
				        result.blink = t;
				      } else {
				        result.name = result.name || "Webkit";
				        result.webkit = t;
				      }

				      if (!result.version && versionIdentifier) {
				        result.version = versionIdentifier;
				      }
				    } else if (!result.opera && /gecko\//i.test(ua)) {
				      result.name = result.name || "Gecko";
				      result.gecko = t;
				      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
				    } // set OS flags for platforms that have multiple browsers


				    if (!result.windowsphone && !result.msedge && (android || result.silk)) {
				      result.android = t;
				    } else if (!result.windowsphone && !result.msedge && iosdevice) {
				      result[iosdevice] = t;
				      result.ios = t;
				    } else if (mac) {
				      result.mac = t;
				    } else if (xbox) {
				      result.xbox = t;
				    } else if (windows) {
				      result.windows = t;
				    } else if (linux) {
				      result.linux = t;
				    } // OS version extraction


				    var osVersion = '';

				    if (result.windowsphone) {
				      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
				    } else if (iosdevice) {
				      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
				      osVersion = osVersion.replace(/[_\s]/g, '.');
				    } else if (android) {
				      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
				    } else if (result.webos) {
				      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
				    } else if (result.blackberry) {
				      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
				    } else if (result.bada) {
				      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
				    } else if (result.tizen) {
				      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
				    }

				    if (osVersion) {
				      result.osversion = osVersion;
				    } // device type extraction


				    var osMajorVersion = osVersion.split('.')[0];

				    if (tablet || nexusTablet || iosdevice == 'ipad' || android && (osMajorVersion == 3 || osMajorVersion >= 4 && !mobile) || result.silk) {
				      result.tablet = t;
				    } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || nexusMobile || result.blackberry || result.webos || result.bada) {
				      result.mobile = t;
				    } // Graded Browser Support
				    // http://developer.yahoo.com/yui/articles/gbs


				    if (result.msedge || result.msie && result.version >= 10 || result.yandexbrowser && result.version >= 15 || result.vivaldi && result.version >= 1.0 || result.chrome && result.version >= 20 || result.samsungBrowser && result.version >= 4 || result.firefox && result.version >= 20.0 || result.safari && result.version >= 6 || result.opera && result.version >= 10.0 || result.ios && result.osversion && result.osversion.split(".")[0] >= 6 || result.blackberry && result.version >= 10.1 || result.chromium && result.version >= 20) {
				      result.a = t;
				    } else if (result.msie && result.version < 10 || result.chrome && result.version < 20 || result.firefox && result.version < 20.0 || result.safari && result.version < 6 || result.opera && result.version < 10.0 || result.ios && result.osversion && result.osversion.split(".")[0] < 6 || result.chromium && result.version < 20) {
				      result.c = t;
				    } else result.x = t;

				    return result;
				  }

				  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '');

				  bowser.test = function (browserList) {
				    for (var i = 0; i < browserList.length; ++i) {
				      var browserItem = browserList[i];

				      if (typeof browserItem === 'string') {
				        if (browserItem in bowser) {
				          return true;
				        }
				      }
				    }

				    return false;
				  };
				  /**
				   * Get version precisions count
				   *
				   * @example
				   *   getVersionPrecision("1.10.3") // 3
				   *
				   * @param  {string} version
				   * @return {number}
				   */


				  function getVersionPrecision(version) {
				    return version.split(".").length;
				  }
				  /**
				   * Array::map polyfill
				   *
				   * @param  {Array} arr
				   * @param  {Function} iterator
				   * @return {Array}
				   */


				  function map(arr, iterator) {
				    var result = [],
				        i;

				    if (Array.prototype.map) {
				      return Array.prototype.map.call(arr, iterator);
				    }

				    for (i = 0; i < arr.length; i++) {
				      result.push(iterator(arr[i]));
				    }

				    return result;
				  }
				  /**
				   * Calculate browser version weight
				   *
				   * @example
				   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
				   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
				   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
				   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
				   *
				   * @param  {Array<String>} versions versions to compare
				   * @return {Number} comparison result
				   */


				  function compareVersions(versions) {
				    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
				    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
				    var chunks = map(versions, function (version) {
				      var delta = precision - getVersionPrecision(version); // 2) "9" -> "9.0" (for precision = 2)

				      version = version + new Array(delta + 1).join(".0"); // 3) "9.0" -> ["000000000"", "000000009"]

				      return map(version.split("."), function (chunk) {
				        return new Array(20 - chunk.length).join("0") + chunk;
				      }).reverse();
				    }); // iterate in reverse order by reversed chunks array

				    while (--precision >= 0) {
				      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
				      if (chunks[0][precision] > chunks[1][precision]) {
				        return 1;
				      } else if (chunks[0][precision] === chunks[1][precision]) {
				        if (precision === 0) {
				          // all version chunks are same
				          return 0;
				        }
				      } else {
				        return -1;
				      }
				    }
				  }
				  /**
				   * Check if browser is unsupported
				   *
				   * @example
				   *   bowser.isUnsupportedBrowser({
				   *     msie: "10",
				   *     firefox: "23",
				   *     chrome: "29",
				   *     safari: "5.1",
				   *     opera: "16",
				   *     phantom: "534"
				   *   });
				   *
				   * @param  {Object}  minVersions map of minimal version to browser
				   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
				   * @param  {String}  [ua] user agent string
				   * @return {Boolean}
				   */


				  function isUnsupportedBrowser(minVersions, strictMode, ua) {
				    var _bowser = bowser; // make strictMode param optional with ua param usage

				    if (typeof strictMode === 'string') {
				      ua = strictMode;
				      strictMode = void 0;
				    }

				    if (strictMode === void 0) {
				      strictMode = false;
				    }

				    if (ua) {
				      _bowser = detect(ua);
				    }

				    var version = "" + _bowser.version;

				    for (var browser in minVersions) {
				      if (minVersions.hasOwnProperty(browser)) {
				        if (_bowser[browser]) {
				          if (typeof minVersions[browser] !== 'string') {
				            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
				          } // browser version and min supported version.


				          return compareVersions([version, minVersions[browser]]) < 0;
				        }
				      }
				    }

				    return strictMode; // not found
				  }
				  /**
				   * Check if browser is supported
				   *
				   * @param  {Object} minVersions map of minimal version to browser
				   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
				   * @param  {String}  [ua] user agent string
				   * @return {Boolean}
				   */


				  function check(minVersions, strictMode, ua) {
				    return !isUnsupportedBrowser(minVersions, strictMode, ua);
				  }

				  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
				  bowser.compareVersions = compareVersions;
				  bowser.check = check;
				  /*
				   * Set our detect method to the main bowser object so we can
				   * reuse it to test other user agents.
				   * This is needed to implement future tests.
				   */

				  bowser._detect = detect;
				  return bowser;
				});
			}
		}
	},
	"pinkie": {
		"index.js": function (exports, module, require) {
			

			var PENDING = 'pending';
			var SETTLED = 'settled';
			var FULFILLED = 'fulfilled';
			var REJECTED = 'rejected';

			var NOOP = function NOOP() {};

			var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';
			var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
			var asyncQueue = [];
			var asyncTimer;

			function asyncFlush() {
			  // run promise callbacks
			  for (var i = 0; i < asyncQueue.length; i++) {
			    asyncQueue[i][0](asyncQueue[i][1]);
			  } // reset async asyncQueue


			  asyncQueue = [];
			  asyncTimer = false;
			}

			function asyncCall(callback, arg) {
			  asyncQueue.push([callback, arg]);

			  if (!asyncTimer) {
			    asyncTimer = true;
			    asyncSetTimer(asyncFlush, 0);
			  }
			}

			function invokeResolver(resolver, promise) {
			  function resolvePromise(value) {
			    resolve(promise, value);
			  }

			  function rejectPromise(reason) {
			    reject(promise, reason);
			  }

			  try {
			    resolver(resolvePromise, rejectPromise);
			  } catch (e) {
			    rejectPromise(e);
			  }
			}

			function invokeCallback(subscriber) {
			  var owner = subscriber.owner;
			  var settled = owner._state;
			  var value = owner._data;
			  var callback = subscriber[settled];
			  var promise = subscriber.then;

			  if (typeof callback === 'function') {
			    settled = FULFILLED;

			    try {
			      value = callback(value);
			    } catch (e) {
			      reject(promise, e);
			    }
			  }

			  if (!handleThenable(promise, value)) {
			    if (settled === FULFILLED) {
			      resolve(promise, value);
			    }

			    if (settled === REJECTED) {
			      reject(promise, value);
			    }
			  }
			}

			function handleThenable(promise, value) {
			  var resolved;

			  try {
			    if (promise === value) {
			      throw new TypeError('A promises callback cannot return that same promise.');
			    }

			    if (value && (typeof value === 'function' || typeof value === 'object')) {
			      // then should be retrieved only once
			      var then = value.then;

			      if (typeof then === 'function') {
			        then.call(value, function (val) {
			          if (!resolved) {
			            resolved = true;

			            if (value === val) {
			              fulfill(promise, val);
			            } else {
			              resolve(promise, val);
			            }
			          }
			        }, function (reason) {
			          if (!resolved) {
			            resolved = true;
			            reject(promise, reason);
			          }
			        });
			        return true;
			      }
			    }
			  } catch (e) {
			    if (!resolved) {
			      reject(promise, e);
			    }

			    return true;
			  }

			  return false;
			}

			function resolve(promise, value) {
			  if (promise === value || !handleThenable(promise, value)) {
			    fulfill(promise, value);
			  }
			}

			function fulfill(promise, value) {
			  if (promise._state === PENDING) {
			    promise._state = SETTLED;
			    promise._data = value;
			    asyncCall(publishFulfillment, promise);
			  }
			}

			function reject(promise, reason) {
			  if (promise._state === PENDING) {
			    promise._state = SETTLED;
			    promise._data = reason;
			    asyncCall(publishRejection, promise);
			  }
			}

			function publish(promise) {
			  promise._then = promise._then.forEach(invokeCallback);
			}

			function publishFulfillment(promise) {
			  promise._state = FULFILLED;
			  publish(promise);
			}

			function publishRejection(promise) {
			  promise._state = REJECTED;
			  publish(promise);

			  if (!promise._handled && isNode) {
			    global.process.emit('unhandledRejection', promise._data, promise);
			  }
			}

			function notifyRejectionHandled(promise) {
			  global.process.emit('rejectionHandled', promise);
			}
			/**
			 * @class
			 */


			function Promise(resolver) {
			  if (typeof resolver !== 'function') {
			    throw new TypeError('Promise resolver ' + resolver + ' is not a function');
			  }

			  if (this instanceof Promise === false) {
			    throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
			  }

			  this._then = [];
			  invokeResolver(resolver, this);
			}

			Promise.prototype = {
			  constructor: Promise,
			  _state: PENDING,
			  _then: null,
			  _data: undefined,
			  _handled: false,
			  then: function then(onFulfillment, onRejection) {
			    var subscriber = {
			      owner: this,
			      then: new this.constructor(NOOP),
			      fulfilled: onFulfillment,
			      rejected: onRejection
			    };

			    if ((onRejection || onFulfillment) && !this._handled) {
			      this._handled = true;

			      if (this._state === REJECTED && isNode) {
			        asyncCall(notifyRejectionHandled, this);
			      }
			    }

			    if (this._state === FULFILLED || this._state === REJECTED) {
			      // already resolved, call callback async
			      asyncCall(invokeCallback, subscriber);
			    } else {
			      // subscribe
			      this._then.push(subscriber);
			    }

			    return subscriber.then;
			  },
			  catch: function _catch(onRejection) {
			    return this.then(null, onRejection);
			  }
			};

			Promise.all = function (promises) {
			  if (!Array.isArray(promises)) {
			    throw new TypeError('You must pass an array to Promise.all().');
			  }

			  return new Promise(function (resolve, reject) {
			    var results = [];
			    var remaining = 0;

			    function resolver(index) {
			      remaining++;
			      return function (value) {
			        results[index] = value;

			        if (! --remaining) {
			          resolve(results);
			        }
			      };
			    }

			    for (var i = 0, promise; i < promises.length; i++) {
			      promise = promises[i];

			      if (promise && typeof promise.then === 'function') {
			        promise.then(resolver(i), reject);
			      } else {
			        results[i] = promise;
			      }
			    }

			    if (!remaining) {
			      resolve(results);
			    }
			  });
			};

			Promise.race = function (promises) {
			  if (!Array.isArray(promises)) {
			    throw new TypeError('You must pass an array to Promise.race().');
			  }

			  return new Promise(function (resolve, reject) {
			    for (var i = 0, promise; i < promises.length; i++) {
			      promise = promises[i];

			      if (promise && typeof promise.then === 'function') {
			        promise.then(resolve, reject);
			      } else {
			        resolve(promise);
			      }
			    }
			  });
			};

			Promise.resolve = function (value) {
			  if (value && typeof value === 'object' && value.constructor === Promise) {
			    return value;
			  }

			  return new Promise(function (resolve) {
			    resolve(value);
			  });
			};

			Promise.reject = function (reason) {
			  return new Promise(function (resolve, reject) {
			    reject(reason);
			  });
			};

			module.exports = Promise;
		}
	},
	"testcafe-hammerhead": {
		"src": {
			"client": {
				"sandbox": {
					"base.js": function (exports, module, require) {
						

						function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

						function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var event_emitter_1 = __importDefault(require("../utils/event-emitter"));

						var native_methods_1 = __importDefault(require("./native-methods"));

						var dom_1 = require("../utils/dom");

						var internal_properties_1 = __importDefault(require("../../processing/dom/internal-properties"));

						var SandboxBase = /*#__PURE__*/function (_event_emitter_1$defa) {
						  _inheritsLoose(SandboxBase, _event_emitter_1$defa);

						  function SandboxBase() {
						    var _this;

						    _this = _event_emitter_1$defa.apply(this, arguments) || this;
						    _this.window = null;
						    _this.nativeMethods = native_methods_1.default;
						    _this.document = null;
						    return _this;
						  } // NOTE: The sandbox is deactivated when its window is removed from the DOM.


						  var _proto = SandboxBase.prototype;

						  _proto.isDeactivated = function isDeactivated() {
						    try {
						      // NOTE: In IE11, a situation when the document is not active may occur.
						      // eslint-disable-next-line no-unused-expressions
						      this.document.body;

						      if (this.window[internal_properties_1.default.hammerhead]) {
						        var frameElement = dom_1.getFrameElement(this.window);
						        return !!frameElement && !dom_1.isElementInDocument(frameElement, dom_1.findDocument(frameElement));
						      }
						    } catch (e) {// eslint-disable-line no-empty
						    }

						    return true;
						  };

						  _proto.attach = function attach(window, document) {
						    this.window = window;
						    this.document = document || window.document;
						  };

						  return SandboxBase;
						}(event_emitter_1.default);

						exports.default = SandboxBase;
						module.exports = exports.default;
					},
					"fetch.js": function (exports, module, require) {
						

						function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

						function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						var __importStar = void 0 && (void 0).__importStar || function (mod) {
						  if (mod && mod.__esModule) return mod;
						  var result = {};
						  if (mod != null) for (var k in mod) {
						    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
						  }
						  result["default"] = mod;
						  return result;
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var sandbox_base_with_delayed_settings_1 = __importDefault(require("../worker/sandbox-base-with-delayed-settings"));

						var native_methods_1 = __importDefault(require("./native-methods"));

						var builtin_header_names_1 = __importDefault(require("../../request-pipeline/builtin-header-names"));

						var url_1 = require("../utils/url");

						var dom_1 = require("../utils/dom");

						var overriding_1 = require("../utils/overriding");

						var browserUtils = __importStar(require("../utils/browser"));

						var url_2 = require("../../utils/url");

						var headers_1 = require("../../utils/headers");

						function getCredentialsMode(credentialsOpt) {
						  credentialsOpt = String(credentialsOpt).toLowerCase();

						  switch (credentialsOpt) {
						    case 'omit':
						      return url_2.Credentials.omit;

						    case 'same-origin':
						      return url_2.Credentials.sameOrigin;

						    case 'include':
						      return url_2.Credentials.include;

						    default:
						      return url_2.Credentials.unknown;
						  }
						}

						var DEFAULT_REQUEST_CREDENTIALS = getCredentialsMode(native_methods_1.default.Request && new native_methods_1.default.Request(location.toString()).credentials);

						var FetchSandbox = /*#__PURE__*/function (_sandbox_base_with_de) {
						  _inheritsLoose(FetchSandbox, _sandbox_base_with_de);

						  function FetchSandbox(cookieSandbox, waitHammerheadSettings) {
						    var _this;

						    _this = _sandbox_base_with_de.call(this, waitHammerheadSettings) || this;
						    _this.cookieSandbox = cookieSandbox;
						    _this.FETCH_REQUEST_SENT_EVENT = 'hammerhead|event|fetch-request-sent-event';
						    return _this;
						  }

						  FetchSandbox._removeAuthHeadersPrefix = function _removeAuthHeadersPrefix(name, value) {
						    if (headers_1.isAuthorizationHeader(name)) return headers_1.removeAuthorizationPrefix(value);else if (headers_1.isAuthenticateHeader(name)) return headers_1.removeAuthenticatePrefix(value);
						    return value;
						  };

						  FetchSandbox._processInit = function _processInit(init) {
						    var headers = init.headers;
						    if (!headers) return init;

						    if (!dom_1.isFetchHeaders(headers)) {
						      headers = headers ? new native_methods_1.default.Headers(headers) : new native_methods_1.default.Headers();
						      init.headers = headers;
						    }

						    var authorizationValue = native_methods_1.default.headersGet.call(headers, builtin_header_names_1.default.authorization);
						    var proxyAuthorizationValue = native_methods_1.default.headersGet.call(headers, builtin_header_names_1.default.proxyAuthorization);
						    if (authorizationValue !== null && !headers_1.hasAuthorizationPrefix(authorizationValue)) native_methods_1.default.headersSet.call(headers, builtin_header_names_1.default.authorization, headers_1.addAuthorizationPrefix(authorizationValue));
						    if (proxyAuthorizationValue !== null && !headers_1.hasAuthorizationPrefix(proxyAuthorizationValue)) native_methods_1.default.headersSet.call(headers, builtin_header_names_1.default.proxyAuthorization, headers_1.addAuthorizationPrefix(proxyAuthorizationValue));
						    return init;
						  };

						  FetchSandbox._processArguments = function _processArguments(args) {
						    var input = args[0],
						        init = args[1];
						    var inputIsString = typeof input === 'string';
						    var optsCredentials = getCredentialsMode(init && init.credentials);

						    if (!dom_1.isFetchRequest(input)) {
						      var url = inputIsString ? input : String(input);
						      var credentials = optsCredentials === url_2.Credentials.unknown ? DEFAULT_REQUEST_CREDENTIALS : optsCredentials;
						      args[0] = url_1.getAjaxProxyUrl(url, credentials);
						      args[1] = FetchSandbox._processInit(init || {});
						    } else {
						      if (optsCredentials !== url_2.Credentials.unknown) args[0] = url_1.getAjaxProxyUrl(input.url, optsCredentials);
						      if (init && init.headers && input.destination !== 'worker') args[1] = FetchSandbox._processInit(init);
						    }
						  };

						  FetchSandbox._processHeaderEntry = function _processHeaderEntry(entry, isOnlyValue) {
						    if (isOnlyValue === void 0) {
						      isOnlyValue = false;
						    }

						    if (entry.done) return entry;
						    /* eslint-disable no-restricted-properties */

						    var processedValue = FetchSandbox._removeAuthHeadersPrefix(entry.value[0], entry.value[1]);

						    if (isOnlyValue) entry.value = processedValue;else entry.value[1] = processedValue;
						    /* eslint-enable no-restricted-properties */

						    return entry;
						  };

						  FetchSandbox._entriesWrapper = function _entriesWrapper() {
						    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
						      args[_key] = arguments[_key];
						    }

						    var iterator = native_methods_1.default.headersEntries.apply(this, args);
						    var nativeNext = iterator.next;

						    iterator.next = function () {
						      return FetchSandbox._processHeaderEntry(nativeNext.call(iterator));
						    };

						    return iterator;
						  };

						  FetchSandbox._valuesWrapper = function _valuesWrapper() {
						    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
						      args[_key2] = arguments[_key2];
						    }

						    var iterator = native_methods_1.default.headersEntries.apply(this, args);
						    var nativeNext = iterator.next;

						    iterator.next = function () {
						      return FetchSandbox._processHeaderEntry(nativeNext.call(iterator), true);
						    };

						    return iterator;
						  };

						  var _proto = FetchSandbox.prototype;

						  _proto.attach = function attach(window) {
						    _sandbox_base_with_de.prototype.attach.call(this, window, window.document);

						    if (!native_methods_1.default.fetch) return;
						    var sandbox = this;
						    overriding_1.overrideConstructor(window, 'Request', function () {
						      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
						        args[_key3] = arguments[_key3];
						      }

						      FetchSandbox._processArguments(args);

						      window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = native_methods_1.default.headersEntries;
						      var request = args.length === 1 ? new native_methods_1.default.Request(args[0]) : new native_methods_1.default.Request(args[0], args[1]);
						      window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = FetchSandbox._entriesWrapper;
						      return request;
						    });
						    overriding_1.overrideDescriptor(window.Request.prototype, 'url', {
						      getter: function getter() {
						        return url_1.getDestinationUrl(native_methods_1.default.requestUrlGetter.call(this));
						      }
						    });
						    overriding_1.overrideDescriptor(window.Request.prototype, 'referrer', {
						      getter: function getter() {
						        return url_1.getDestinationUrl(native_methods_1.default.requestReferrerGetter.call(this));
						      }
						    });
						    overriding_1.overrideFunction(window, 'fetch', function () {
						      var _this2 = this;

						      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
						        args[_key4] = arguments[_key4];
						      }

						      if (sandbox.gettingSettingInProgress()) return sandbox.delayUntilGetSettings(function () {
						        return _this2.fetch.apply(_this2, args);
						      }); // NOTE: Safari processed the empty `fetch()` request without `Promise` rejection (GH-1613)

						      if (!args.length && !browserUtils.isSafari) return native_methods_1.default.fetch.apply(this, args);

						      try {
						        FetchSandbox._processArguments(args);
						      } catch (e) {
						        return native_methods_1.default.promiseReject.call(sandbox.window.Promise, e);
						      }

						      window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = native_methods_1.default.headersEntries;
						      var fetchPromise = native_methods_1.default.fetch.apply(this, args);
						      window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = FetchSandbox._entriesWrapper;
						      sandbox.emit(sandbox.FETCH_REQUEST_SENT_EVENT, fetchPromise);
						      return native_methods_1.default.promiseThen.call(fetchPromise, function (response) {
						        sandbox.cookieSandbox.syncCookie();
						        return response;
						      });
						    });
						    overriding_1.overrideDescriptor(window.Response.prototype, 'url', {
						      getter: function getter() {
						        return url_1.getDestinationUrl(native_methods_1.default.responseUrlGetter.call(this));
						      }
						    });
						    overriding_1.overrideFunction(window.Headers.prototype, 'entries', FetchSandbox._entriesWrapper);
						    overriding_1.overrideFunction(window.Headers.prototype, Symbol.iterator, FetchSandbox._entriesWrapper);
						    overriding_1.overrideFunction(window.Headers.prototype, 'values', FetchSandbox._valuesWrapper);
						    overriding_1.overrideFunction(window.Headers.prototype, 'forEach', function () {
						      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
						        args[_key5] = arguments[_key5];
						      }

						      var callback = args[0];

						      if (typeof callback === 'function') {
						        args[0] = function (value, name, headers) {
						          value = FetchSandbox._removeAuthHeadersPrefix(name, value);
						          callback.call(this, value, name, headers);
						        };
						      }

						      return native_methods_1.default.headersForEach.apply(this, args);
						    });
						    overriding_1.overrideFunction(window.Headers.prototype, 'get', function () {
						      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
						        args[_key6] = arguments[_key6];
						      }

						      var value = native_methods_1.default.headersGet.apply(this, args);
						      return value && FetchSandbox._removeAuthHeadersPrefix(args[0], value);
						    });
						    overriding_1.overrideFunction(window.Headers.prototype, 'set', function () {
						      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
						        args[_key7] = arguments[_key7];
						      }

						      if (headers_1.isAuthorizationHeader(args[0])) args[1] = headers_1.addAuthorizationPrefix(args[1]);
						      return native_methods_1.default.headersSet.apply(this, args);
						    });
						  };

						  return FetchSandbox;
						}(sandbox_base_with_delayed_settings_1.default);

						exports.default = FetchSandbox;
						module.exports = exports.default;
					},
					"native-methods.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});
						/*global Document, Window */

						var global_context_info_1 = __importDefault(require("../utils/global-context-info"));

						var overriding_1 = require("../utils/overriding");

						var NATIVE_CODE_RE = /\[native code]/;

						var NativeMethods = /*#__PURE__*/function () {
						  function NativeMethods(doc, win) {
						    win = win || global_context_info_1.default.global;
						    this.refreshWindowMeths(win, global_context_info_1.default.isInWorker);
						    if (global_context_info_1.default.isInWorker) return;
						    this.refreshDocumentMeths(doc, win);
						    this.refreshElementMeths(doc, win);
						  }

						  NativeMethods._getDocumentPropOwnerName = function _getDocumentPropOwnerName(docPrototype, propName) {
						    return docPrototype.hasOwnProperty(propName) ? 'Document' : 'HTMLDocument';
						  };

						  var _proto = NativeMethods.prototype;

						  _proto.getStoragesPropsOwner = function getStoragesPropsOwner(win) {
						    return this.isStoragePropsLocatedInProto ? win.Window.prototype : win;
						  };

						  _proto.refreshDocumentMeths = function refreshDocumentMeths(doc, win) {
						    doc = doc || document;
						    win = win || window;
						    var docPrototype = win.Document.prototype; // Dom

						    this.createDocumentFragment = docPrototype.createDocumentFragment;
						    this.createElement = docPrototype.createElement;
						    this.createElementNS = docPrototype.createElementNS;
						    this.createTextNode = docPrototype.createTextNode;
						    this.documentOpenPropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'open');
						    this.documentClosePropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'close');
						    this.documentWritePropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'write');
						    this.documentWriteLnPropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'writeln');
						    this.documentOpen = win[this.documentOpenPropOwnerName].prototype.open;
						    this.documentClose = win[this.documentClosePropOwnerName].prototype.close;
						    this.documentWrite = win[this.documentWritePropOwnerName].prototype.write;
						    this.documentWriteLn = win[this.documentWriteLnPropOwnerName].prototype.writeln;
						    this.elementFromPoint = docPrototype.elementFromPoint;
						    this.caretRangeFromPoint = docPrototype.caretRangeFromPoint;
						    this.caretPositionFromPoint = docPrototype.caretPositionFromPoint;
						    this.getElementById = docPrototype.getElementById;
						    this.getElementsByClassName = docPrototype.getElementsByClassName;
						    this.getElementsByName = docPrototype.getElementsByName;
						    this.getElementsByTagName = docPrototype.getElementsByTagName;
						    this.querySelector = docPrototype.querySelector;
						    this.querySelectorAll = docPrototype.querySelectorAll;
						    this.createHTMLDocument = win.DOMImplementation.prototype.createHTMLDocument; // @ts-ignore

						    if (doc.registerElement) {
						      // @ts-ignore
						      this.registerElement = docPrototype.registerElement;
						    } // Event
						    // NOTE: IE11 has no EventTarget so we should save "Event" methods separately


						    if (!win.EventTarget) {
						      this.documentAddEventListener = docPrototype.addEventListener;
						      this.documentRemoveEventListener = docPrototype.removeEventListener;
						    }

						    this.documentCreateEvent = docPrototype.createEvent; // @ts-ignore Deprecated

						    this.documentCreateTouch = docPrototype.createTouch; // @ts-ignore Deprecated

						    this.documentCreateTouchList = docPrototype.createTouchList; // getters/setters

						    this.documentCookiePropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'cookie');
						    this.documentScriptsPropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'scripts');
						    var documentCookieDescriptor = win.Object.getOwnPropertyDescriptor(win[this.documentCookiePropOwnerName].prototype, 'cookie'); // TODO: remove this condition after the GH-1649 fix

						    if (!this.isNativeCode(documentCookieDescriptor.get) || !this.isNativeCode(documentCookieDescriptor.get.toString)) {
						      try {
						        var parentNativeMethods = win.parent['%hammerhead%'].nativeMethods;
						        documentCookieDescriptor.get = parentNativeMethods.documentCookieGetter;
						        documentCookieDescriptor.set = parentNativeMethods.documentCookieSetter;
						      } catch (_a) {} // eslint-disable-line no-empty

						    }

						    this.documentReferrerGetter = win.Object.getOwnPropertyDescriptor(docPrototype, 'referrer').get;
						    this.documentStyleSheetsGetter = win.Object.getOwnPropertyDescriptor(docPrototype, 'styleSheets').get;
						    this.documentActiveElementGetter = win.Object.getOwnPropertyDescriptor(docPrototype, 'activeElement').get;
						    this.documentScriptsGetter = win.Object.getOwnPropertyDescriptor(win[this.documentScriptsPropOwnerName].prototype, 'scripts').get;
						    this.documentCookieGetter = documentCookieDescriptor.get;
						    this.documentCookieSetter = documentCookieDescriptor.set;
						    var documentDocumentURIDescriptor = win.Object.getOwnPropertyDescriptor(docPrototype, 'documentURI');
						    if (documentDocumentURIDescriptor) this.documentDocumentURIGetter = documentDocumentURIDescriptor.get;
						    var documentTitleDescriptor = win.Object.getOwnPropertyDescriptor(docPrototype, 'title');
						    this.documentTitleGetter = documentTitleDescriptor.get;
						    this.documentTitleSetter = documentTitleDescriptor.set;
						  };

						  _proto.refreshElementMeths = function refreshElementMeths(doc, win) {
						    var _this = this;

						    win = win || window;

						    var createElement = function createElement(tagName) {
						      return _this.createElement.call(doc || document, tagName);
						    };

						    var nativeElement = createElement('div');

						    var createTextNode = function createTextNode(data) {
						      return _this.createTextNode.call(doc || document, data);
						    };

						    var textNode = createTextNode('text'); // Dom

						    this.appendChild = win.Node.prototype.appendChild;
						    this.append = win.Element.prototype.append;
						    this.attachShadow = win.Element.prototype.attachShadow;
						    this.replaceChild = nativeElement.replaceChild;
						    this.cloneNode = nativeElement.cloneNode;
						    this.elementGetElementsByClassName = nativeElement.getElementsByClassName;
						    this.elementGetElementsByTagName = nativeElement.getElementsByTagName;
						    this.elementQuerySelector = nativeElement.querySelector;
						    this.elementQuerySelectorAll = nativeElement.querySelectorAll;
						    this.getAttribute = nativeElement.getAttribute;
						    this.getAttributeNS = nativeElement.getAttributeNS;
						    this.insertAdjacentHTML = nativeElement.insertAdjacentHTML;
						    this.insertBefore = nativeElement.insertBefore;
						    this.insertCell = createElement('tr').insertCell;
						    this.insertTableRow = createElement('table').insertRow;
						    this.insertTBodyRow = createElement('tbody').insertRow;
						    this.removeAttribute = nativeElement.removeAttribute;
						    this.removeAttributeNS = nativeElement.removeAttributeNS;
						    this.removeChild = win.Node.prototype.removeChild;
						    this.remove = win.Element.prototype.remove;
						    this.setAttribute = nativeElement.setAttribute;
						    this.setAttributeNS = nativeElement.setAttributeNS;
						    this.hasAttribute = nativeElement.hasAttribute;
						    this.hasAttributeNS = nativeElement.hasAttributeNS;
						    this.hasAttributes = nativeElement.hasAttributes;
						    this.anchorToString = win.HTMLAnchorElement.prototype.toString;
						    this.matches = nativeElement.matches || nativeElement.msMatchesSelector;
						    this.closest = nativeElement.closest; // Text node

						    this.appendData = textNode.appendData; // TODO: remove this condition after the GH-1649 fix

						    if (!this.isNativeCode(this.elementGetElementsByTagName)) {
						      try {
						        var parentNativeMethods = win.parent['%hammerhead%'].nativeMethods;
						        this.elementGetElementsByTagName = parentNativeMethods.elementGetElementsByTagName;
						      } // eslint-disable-next-line no-empty
						      catch (e) {}
						    } // Event


						    if (win.EventTarget) {
						      this.addEventListener = win.EventTarget.prototype.addEventListener;
						      this.removeEventListener = win.EventTarget.prototype.removeEventListener;
						      this.dispatchEvent = win.EventTarget.prototype.dispatchEvent;
						    } // NOTE: IE11 has no EventTarget
						    else {
						        this.addEventListener = nativeElement.addEventListener;
						        this.removeEventListener = nativeElement.removeEventListener;
						        this.dispatchEvent = nativeElement.dispatchEvent;
						      }

						    this.blur = nativeElement.blur;
						    this.click = nativeElement.click;
						    this.focus = nativeElement.focus; // @ts-ignore

						    this.select = window.TextRange ? createElement('body').createTextRange().select : null;
						    this.setSelectionRange = createElement('input').setSelectionRange;
						    this.textAreaSetSelectionRange = createElement('textarea').setSelectionRange;
						    this.svgFocus = win.SVGElement ? win.SVGElement.prototype.focus : this.focus;
						    this.svgBlur = win.SVGElement ? win.SVGElement.prototype.blur : this.blur; // Style
						    // NOTE: The 'style' descriptor is located in the Element.prototype in the Safari on IOS

						    this.htmlElementStylePropOwnerName = win.Element.prototype.hasOwnProperty('style') ? 'Element' : 'HTMLElement';
						    var htmlElementStyleDescriptor = win.Object.getOwnPropertyDescriptor(win[this.htmlElementStylePropOwnerName].prototype, 'style');
						    this.htmlElementStyleGetter = htmlElementStyleDescriptor.get; // NOTE: IE does not allow to set a style property

						    if (htmlElementStyleDescriptor.set) this.htmlElementStyleSetter = htmlElementStyleDescriptor.set;
						    var styleCssTextDescriptor = win.Object.getOwnPropertyDescriptor(win.CSSStyleDeclaration.prototype, 'cssText');
						    this.styleCssTextGetter = styleCssTextDescriptor.get;
						    this.styleCssTextSetter = styleCssTextDescriptor.set;
						  };

						  _proto._refreshGettersAndSetters = function _refreshGettersAndSetters(win, isInWorker) {
						    if (isInWorker === void 0) {
						      isInWorker = false;
						    }

						    win = win || window;
						    var winProto = win.constructor.prototype; // NOTE: Event properties is located in window prototype only in IE11

						    this.isEventPropsLocatedInProto = winProto.hasOwnProperty('onerror');
						    var eventPropsOwner = this.isEventPropsLocatedInProto ? winProto : win;
						    var winOnBeforeUnloadDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onbeforeunload');
						    var winOnUnloadDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onunload');
						    var winOnPageHideDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onpagehide');
						    var winOnMessageDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onmessage');
						    var winOnErrorDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onerror');
						    var winOnHashChangeDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onhashchange');
						    this.winOnBeforeUnloadSetter = winOnBeforeUnloadDescriptor && winOnBeforeUnloadDescriptor.set;
						    this.winOnUnloadSetter = winOnUnloadDescriptor && winOnUnloadDescriptor.set;
						    this.winOnPageHideSetter = winOnPageHideDescriptor && winOnPageHideDescriptor.set;
						    this.winOnMessageSetter = winOnMessageDescriptor && winOnMessageDescriptor.set;
						    this.winOnErrorSetter = winOnErrorDescriptor && winOnErrorDescriptor.set;
						    this.winOnHashChangeSetter = winOnHashChangeDescriptor && winOnHashChangeDescriptor.set;
						    var winOnUnhandledRejectionDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onunhandledrejection');
						    if (winOnUnhandledRejectionDescriptor) this.winOnUnhandledRejectionSetter = winOnUnhandledRejectionDescriptor.set; // Getters

						    if (win.WebSocket) {
						      var urlPropDescriptor = win.Object.getOwnPropertyDescriptor(win.WebSocket.prototype, 'url');
						      if (urlPropDescriptor && urlPropDescriptor.get && urlPropDescriptor.configurable) this.webSocketUrlGetter = urlPropDescriptor.get;
						    }

						    this.messageEventOriginGetter = win.Object.getOwnPropertyDescriptor(win.MessageEvent.prototype, 'origin').get; // NOTE: At present we proxy only the PerformanceNavigationTiming.
						    // Another types of the PerformanceEntry will be fixed later
						    // https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry

						    if (win.PerformanceNavigationTiming) this.performanceEntryNameGetter = win.Object.getOwnPropertyDescriptor(win.PerformanceEntry.prototype, 'name').get;
						    var dataPropDescriptor = win.Object.getOwnPropertyDescriptor(win.MessageEvent.prototype, 'data'); // NOTE: This condition is used for the Android 6.0 browser

						    if (dataPropDescriptor) this.messageEventDataGetter = dataPropDescriptor.get;

						    if (win.fetch) {
						      this.responseStatusGetter = win.Object.getOwnPropertyDescriptor(win.Response.prototype, 'status').get;
						      this.responseTypeGetter = win.Object.getOwnPropertyDescriptor(win.Response.prototype, 'type').get;
						      this.responseUrlGetter = win.Object.getOwnPropertyDescriptor(win.Response.prototype, 'url').get;
						      this.requestUrlGetter = win.Object.getOwnPropertyDescriptor(win.Request.prototype, 'url').get;
						      this.requestReferrerGetter = win.Object.getOwnPropertyDescriptor(win.Request.prototype, 'referrer').get;
						    }

						    if (win.XMLHttpRequest) {
						      var xhrResponseURLDescriptor = win.Object.getOwnPropertyDescriptor(win.XMLHttpRequest.prototype, 'responseURL'); // NOTE: IE doesn't support the 'responseURL' property

						      if (xhrResponseURLDescriptor) this.xhrResponseURLGetter = xhrResponseURLDescriptor.get;
						    } // eslint-disable-next-line no-restricted-properties


						    if (win.Window) {
						      // NOTE: The 'localStorage' and 'sessionStorage' properties is located in window prototype only in IE11
						      this.isStoragePropsLocatedInProto = win.Window.prototype.hasOwnProperty('localStorage');
						      var storagesPropsOwner = this.getStoragesPropsOwner(win);
						      this.winLocalStorageGetter = win.Object.getOwnPropertyDescriptor(storagesPropsOwner, 'localStorage').get;
						      this.winSessionStorageGetter = win.Object.getOwnPropertyDescriptor(storagesPropsOwner, 'sessionStorage').get;
						    }

						    if (isInWorker) return;
						    this.storageGetItem = win.Storage.prototype.getItem;
						    this.storageSetItem = win.Storage.prototype.setItem;
						    this.storageRemoveItem = win.Storage.prototype.removeItem;
						    this.storageClear = win.Storage.prototype.clear;
						    this.storageKey = win.Storage.prototype.key;
						    this.storageLengthGetter = win.Object.getOwnPropertyDescriptor(win.Storage.prototype, 'length');
						    var objectDataDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLObjectElement.prototype, 'data');
						    var inputTypeDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'type');
						    var inputValueDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'value');
						    var inputDisabledDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'disabled');
						    var inputRequiredDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'required');
						    var textAreaValueDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLTextAreaElement.prototype, 'value');
						    var imageSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLImageElement.prototype, 'src');
						    var scriptSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLScriptElement.prototype, 'src');
						    var scriptIntegrityDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLScriptElement.prototype, 'integrity');
						    var embedSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLEmbedElement.prototype, 'src');
						    var sourceSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLSourceElement.prototype, 'src');
						    var mediaSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLMediaElement.prototype, 'src');
						    var inputSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'src');
						    var frameSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLFrameElement.prototype, 'src');
						    var iframeSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'src');
						    var anchorHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'href');
						    var linkHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLLinkElement.prototype, 'href');
						    var linkIntegrityDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLLinkElement.prototype, 'integrity');
						    var linkRelDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLLinkElement.prototype, 'rel');
						    var linkAsDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLLinkElement.prototype, 'as');
						    var areaHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAreaElement.prototype, 'href');
						    var baseHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLBaseElement.prototype, 'href');
						    var anchorHostDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'host');
						    var anchorHostnameDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'hostname');
						    var anchorPathnameDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'pathname');
						    var anchorPortDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'port');
						    var anchorProtocolDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'protocol');
						    var anchorSearchDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'search');
						    var anchorTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'target');
						    var formTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLFormElement.prototype, 'target');
						    var areaTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAreaElement.prototype, 'target');
						    var baseTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLBaseElement.prototype, 'target');
						    var inputFormTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'formTarget');
						    var buttonFormTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLButtonElement.prototype, 'formTarget');
						    var svgImageHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.SVGImageElement.prototype, 'href');
						    var svgAnimStrAnimValDescriptor = win.Object.getOwnPropertyDescriptor(win.SVGAnimatedString.prototype, 'animVal');
						    var svgAnimStrBaseValDescriptor = win.Object.getOwnPropertyDescriptor(win.SVGAnimatedString.prototype, 'baseVal');
						    var inputAutocompleteDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'autocomplete');
						    var formActionDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLFormElement.prototype, 'action');
						    var inputFormActionDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'formAction');
						    var buttonFormActionDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLButtonElement.prototype, 'formAction');
						    var nodeTextContentDescriptor = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'textContent');
						    var htmlElementInnerTextDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLElement.prototype, 'innerText');
						    var scriptTextDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLScriptElement.prototype, 'text');
						    var anchorTextDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'text');
						    var titleElementTextDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLTitleElement.prototype, 'text');
						    var iframeSandboxDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'sandbox');
						    var windowOriginDescriptor = win.Object.getOwnPropertyDescriptor(win, 'origin');

						    if (windowOriginDescriptor) {
						      this.windowOriginGetter = windowOriginDescriptor.get;
						      this.windowOriginSetter = windowOriginDescriptor.set;
						    } // NOTE: We need 'disabled' property only for Chrome.
						    // In Chrome it's located in HTMLInputElement.prototype
						    // But in IE11 it's located in HTMLElement.prototype
						    // So we need the null check


						    if (inputDisabledDescriptor) {
						      this.inputDisabledSetter = inputDisabledDescriptor.set;
						      this.inputDisabledGetter = inputDisabledDescriptor.get;
						    } // NOTE: Html properties is located in HTMLElement prototype in IE11 only


						    this.elementHTMLPropOwnerName = win.Element.prototype.hasOwnProperty('innerHTML') ? 'Element' : 'HTMLElement';
						    var elementInnerHTMLDescriptor = win.Object.getOwnPropertyDescriptor(win[this.elementHTMLPropOwnerName].prototype, 'innerHTML');
						    var elementOuterHTMLDescriptor = win.Object.getOwnPropertyDescriptor(win[this.elementHTMLPropOwnerName].prototype, 'outerHTML'); // Setters

						    this.objectDataSetter = objectDataDescriptor.set;
						    this.inputTypeSetter = inputTypeDescriptor.set;
						    this.inputValueSetter = inputValueDescriptor.set;
						    this.inputRequiredSetter = inputRequiredDescriptor.set;
						    this.textAreaValueSetter = textAreaValueDescriptor.set;
						    this.imageSrcSetter = imageSrcDescriptor.set;
						    this.scriptSrcSetter = scriptSrcDescriptor.set;
						    this.embedSrcSetter = embedSrcDescriptor.set;
						    this.sourceSrcSetter = sourceSrcDescriptor.set;
						    this.mediaSrcSetter = mediaSrcDescriptor.set;
						    this.inputSrcSetter = inputSrcDescriptor.set;
						    this.frameSrcSetter = frameSrcDescriptor.set;
						    this.iframeSrcSetter = iframeSrcDescriptor.set;
						    this.anchorHrefSetter = anchorHrefDescriptor.set;
						    this.linkHrefSetter = linkHrefDescriptor.set;
						    this.linkRelSetter = linkRelDescriptor.set;
						    this.linkAsSetter = linkAsDescriptor && linkAsDescriptor.set;
						    this.areaHrefSetter = areaHrefDescriptor.set;
						    this.baseHrefSetter = baseHrefDescriptor.set;
						    this.anchorHostSetter = anchorHostDescriptor.set;
						    this.anchorHostnameSetter = anchorHostnameDescriptor.set;
						    this.anchorPathnameSetter = anchorPathnameDescriptor.set;
						    this.anchorPortSetter = anchorPortDescriptor.set;
						    this.anchorProtocolSetter = anchorProtocolDescriptor.set;
						    this.anchorSearchSetter = anchorSearchDescriptor.set;
						    this.anchorTargetSetter = anchorTargetDescriptor.set;
						    this.formTargetSetter = formTargetDescriptor.set;
						    this.areaTargetSetter = areaTargetDescriptor.set;
						    this.baseTargetSetter = baseTargetDescriptor.set;
						    this.inputFormTargetSetter = inputFormTargetDescriptor.set;
						    this.buttonFormTargetSetter = buttonFormTargetDescriptor.set;
						    this.svgAnimStrBaseValSetter = svgAnimStrBaseValDescriptor.set;
						    this.inputAutocompleteSetter = inputAutocompleteDescriptor.set;
						    this.formActionSetter = formActionDescriptor.set;
						    this.inputFormActionSetter = inputFormActionDescriptor.set;
						    this.buttonFormActionSetter = buttonFormActionDescriptor.set;
						    this.iframeSandboxSetter = iframeSandboxDescriptor.set;
						    this.htmlElementOnloadSetter = win.Object.getOwnPropertyDescriptor(win.HTMLElement.prototype, 'onload').set;
						    this.nodeTextContentSetter = nodeTextContentDescriptor.set;
						    this.htmlElementInnerTextSetter = htmlElementInnerTextDescriptor.set;
						    this.scriptTextSetter = scriptTextDescriptor.set;
						    this.anchorTextSetter = anchorTextDescriptor.set;
						    this.elementInnerHTMLSetter = elementInnerHTMLDescriptor.set;
						    this.elementOuterHTMLSetter = elementOuterHTMLDescriptor.set; // NOTE: Some browsers (for example, Edge, Internet Explorer 11, Safari) don't support the 'integrity' property.

						    if (scriptIntegrityDescriptor && linkIntegrityDescriptor) {
						      this.scriptIntegritySetter = scriptIntegrityDescriptor.set;
						      this.linkIntegritySetter = linkIntegrityDescriptor.set;
						    }

						    this.titleElementTextSetter = titleElementTextDescriptor.set; // NOTE: the classList property is located in HTMLElement prototype in IE11

						    this.elementClassListPropOwnerName = win.Element.prototype.hasOwnProperty('classList') ? 'Element' : 'HTMLElement';
						    this.elementClassListGetter = win.Object.getOwnPropertyDescriptor(win[this.elementClassListPropOwnerName].prototype, 'classList').get;
						    this.htmlCollectionLengthGetter = win.Object.getOwnPropertyDescriptor(win.HTMLCollection.prototype, 'length').get;
						    this.nodeListLengthGetter = win.Object.getOwnPropertyDescriptor(win.NodeList.prototype, 'length').get;
						    this.elementChildElementCountGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'childElementCount').get;
						    this.inputFilesGetter = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'files').get;
						    this.styleSheetHrefGetter = win.Object.getOwnPropertyDescriptor(win.StyleSheet.prototype, 'href').get;
						    this.objectDataGetter = objectDataDescriptor.get;
						    this.inputTypeGetter = inputTypeDescriptor.get;
						    this.inputValueGetter = inputValueDescriptor.get;
						    this.inputRequiredGetter = inputRequiredDescriptor.get;
						    this.textAreaValueGetter = textAreaValueDescriptor.get;
						    this.imageSrcGetter = imageSrcDescriptor.get;
						    this.scriptSrcGetter = scriptSrcDescriptor.get;
						    this.embedSrcGetter = embedSrcDescriptor.get;
						    this.sourceSrcGetter = sourceSrcDescriptor.get;
						    this.mediaSrcGetter = mediaSrcDescriptor.get;
						    this.inputSrcGetter = inputSrcDescriptor.get;
						    this.frameSrcGetter = frameSrcDescriptor.get;
						    this.iframeSrcGetter = iframeSrcDescriptor.get;
						    this.anchorHrefGetter = anchorHrefDescriptor.get;
						    this.linkHrefGetter = linkHrefDescriptor.get;
						    this.linkRelGetter = linkRelDescriptor.get;
						    this.areaHrefGetter = areaHrefDescriptor.get;
						    this.baseHrefGetter = baseHrefDescriptor.get;
						    this.anchorHostGetter = anchorHostDescriptor.get;
						    this.anchorHostnameGetter = anchorHostnameDescriptor.get;
						    this.anchorPathnameGetter = anchorPathnameDescriptor.get;
						    this.anchorPortGetter = anchorPortDescriptor.get;
						    this.anchorProtocolGetter = anchorProtocolDescriptor.get;
						    this.anchorSearchGetter = anchorSearchDescriptor.get;
						    this.anchorTargetGetter = anchorTargetDescriptor.get;
						    this.formTargetGetter = formTargetDescriptor.get;
						    this.areaTargetGetter = areaTargetDescriptor.get;
						    this.baseTargetGetter = baseTargetDescriptor.get;
						    this.inputFormTargetGetter = inputFormTargetDescriptor.get;
						    this.buttonFormTargetGetter = buttonFormTargetDescriptor.get;
						    this.svgImageHrefGetter = svgImageHrefDescriptor.get;
						    this.svgAnimStrAnimValGetter = svgAnimStrAnimValDescriptor.get;
						    this.svgAnimStrBaseValGetter = svgAnimStrBaseValDescriptor.get;
						    this.inputAutocompleteGetter = inputAutocompleteDescriptor.get;
						    this.formActionGetter = formActionDescriptor.get;
						    this.inputFormActionGetter = inputFormActionDescriptor.get;
						    this.buttonFormActionGetter = buttonFormActionDescriptor.get;
						    this.iframeSandboxGetter = iframeSandboxDescriptor.get;
						    this.contentWindowGetter = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'contentWindow').get;
						    this.contentDocumentGetter = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'contentDocument').get;
						    this.frameContentWindowGetter = win.Object.getOwnPropertyDescriptor(win.HTMLFrameElement.prototype, 'contentWindow').get;
						    this.nodeTextContentGetter = nodeTextContentDescriptor.get;
						    this.htmlElementInnerTextGetter = htmlElementInnerTextDescriptor.get;
						    this.scriptTextGetter = scriptTextDescriptor.get;
						    this.anchorTextGetter = anchorTextDescriptor.get;
						    this.elementInnerHTMLGetter = elementInnerHTMLDescriptor.get;
						    this.elementOuterHTMLGetter = elementOuterHTMLDescriptor.get;
						    this.nodeFirstChildGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'firstChild').get;
						    this.nodeLastChildGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'lastChild').get;
						    this.nodeNextSiblingGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'nextSibling').get;
						    this.nodePrevSiblingGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'previousSibling').get;
						    this.nodeParentNodeGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'parentNode').get;
						    this.nodeChildNodesGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'childNodes').get;
						    this.elementFirstElementChildGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'firstElementChild').get;
						    this.elementLastElementChildGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'lastElementChild').get;
						    this.elementNextElementSiblingGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'nextElementSibling').get;
						    this.elementPrevElementSiblingGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'previousElementSibling').get; // NOTE: Some browsers (for example, Edge, Internet Explorer 11, Safari) don't support the 'integrity' property.

						    if (scriptIntegrityDescriptor && linkIntegrityDescriptor) {
						      this.scriptIntegrityGetter = scriptIntegrityDescriptor.get;
						      this.linkIntegrityGetter = linkIntegrityDescriptor.get;
						    }

						    var anchorOriginDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'origin'); // NOTE: IE and Edge don't support origin property

						    if (anchorOriginDescriptor) this.anchorOriginGetter = anchorOriginDescriptor.get;
						    var iframeSrcdocDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'srcdoc'); // NOTE: IE11 doesn't support the 'srcdoc' property

						    if (iframeSrcdocDescriptor) {
						      this.iframeSrcdocGetter = iframeSrcdocDescriptor.get;
						      this.iframeSrcdocSetter = iframeSrcdocDescriptor.set;
						    }

						    var cssStyleSheetHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.CSSStyleSheet.prototype, 'href'); // NOTE: IE11 doesn't support the 'href' property

						    if (cssStyleSheetHrefDescriptor) this.cssStyleSheetHrefGetter = cssStyleSheetHrefDescriptor.get;
						    var nodeBaseURIDescriptor = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'baseURI'); // NOTE: IE11 doesn't support the 'baseURI' property

						    if (nodeBaseURIDescriptor) this.nodeBaseURIGetter = nodeBaseURIDescriptor.get; // NOTE: The 'attributes' property is located in Node prototype in IE11 only

						    this.elementAttributesPropOwnerName = win.Element.prototype.hasOwnProperty('attributes') ? 'Element' : 'Node';
						    this.elementAttributesGetter = win.Object.getOwnPropertyDescriptor(win[this.elementAttributesPropOwnerName].prototype, 'attributes').get;
						    var htmlManifestDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLHtmlElement.prototype, 'manifest'); // NOTE: Only the Safari browser supports the 'manifest' property

						    if (htmlManifestDescriptor) {
						      this.htmlManifestGetter = htmlManifestDescriptor.get;
						      this.htmlManifestSetter = htmlManifestDescriptor.set;
						    }

						    this.titleElementTextGetter = titleElementTextDescriptor.get; // MutationRecord

						    this.mutationRecordNextSiblingGetter = win.Object.getOwnPropertyDescriptor(win.MutationRecord.prototype, 'nextSibling').get;
						    this.mutationRecordPrevSiblingGetter = win.Object.getOwnPropertyDescriptor(win.MutationRecord.prototype, 'previousSibling').get;
						  };

						  _proto.refreshWindowMeths = function refreshWindowMeths(win, isInWorker) {
						    if (isInWorker === void 0) {
						      isInWorker = false;
						    }

						    win = win || window;
						    var winProto = win.constructor.prototype; // Dom

						    this.eval = win.eval;
						    this.formSubmit = win.HTMLFormElement && win.HTMLFormElement.prototype.submit;
						    this.documentFragmentQuerySelector = win.DocumentFragment && win.DocumentFragment.prototype.querySelector;
						    this.documentFragmentQuerySelectorAll = win.DocumentFragment && win.DocumentFragment.prototype.querySelectorAll;
						    this.preventDefault = win.Event.prototype.preventDefault;
						    this.historyPushState = win.history && win.history.pushState;
						    this.historyReplaceState = win.history && win.history.replaceState;
						    this.postMessage = win.postMessage || winProto.postMessage;
						    this.windowOpen = win.open || winProto.open;
						    this.setTimeout = win.setTimeout || winProto.setTimeout;
						    this.setInterval = win.setInterval || winProto.setInterval;
						    this.clearTimeout = win.clearTimeout || winProto.clearTimeout;
						    this.clearInterval = win.clearInterval || winProto.clearInterval;
						    this.registerProtocolHandler = win.navigator.registerProtocolHandler;
						    this.sendBeacon = win.navigator.sendBeacon;

						    if (win.XMLHttpRequest) {
						      // NOTE: IE11 has no EventTarget so we should save "Event" methods separately
						      var xhrEventProto = (win.EventTarget || win.XMLHttpRequest).prototype;
						      this.xhrAbort = win.XMLHttpRequest.prototype.abort;
						      this.xhrOpen = win.XMLHttpRequest.prototype.open;
						      this.xhrSend = win.XMLHttpRequest.prototype.send;
						      this.xhrAddEventListener = xhrEventProto.addEventListener;
						      this.xhrRemoveEventListener = xhrEventProto.removeEventListener;
						      this.xhrDispatchEvent = xhrEventProto.dispatchEvent;
						      this.xhrGetResponseHeader = win.XMLHttpRequest.prototype.getResponseHeader;
						      this.xhrGetAllResponseHeaders = win.XMLHttpRequest.prototype.getAllResponseHeaders;
						      this.xhrSetRequestHeader = win.XMLHttpRequest.prototype.setRequestHeader;
						      this.xhrOverrideMimeType = win.XMLHttpRequest.prototype.overrideMimeType;
						    }

						    try {
						      this.registerServiceWorker = win.navigator.serviceWorker.register;
						      this.getRegistrationServiceWorker = win.navigator.serviceWorker.getRegistration;
						    } catch (e) {
						      this.registerServiceWorker = null;
						      this.getRegistrationServiceWorker = null;
						    }

						    this.createContextualFragment = win.Range && win.Range.prototype.createContextualFragment;
						    var nativePerformance = win.performance;

						    if (nativePerformance) {
						      // eslint-disable-next-line no-restricted-properties
						      var nativePerformanceNow = win.performance.now || win.Performance.prototype.now;

						      this.performanceNow = function () {
						        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
						          args[_key] = arguments[_key];
						        }

						        return nativePerformanceNow.apply(nativePerformance, args);
						      };
						    } // Fetch


						    this.fetch = win.fetch;
						    this.Request = win.Request;

						    if (win.Headers) {
						      this.Headers = win.Headers;
						      this.headersSet = win.Headers.prototype.set;
						      this.headersGet = win.Headers.prototype.get;
						      this.headersDelete = win.Headers.prototype.delete;
						      this.headersEntries = win.Headers.prototype.entries;
						      this.headersForEach = win.Headers.prototype.forEach;
						      this.headersValues = win.Headers.prototype.values;
						    } // Event


						    this.windowAddEventListener = win.addEventListener || winProto.addEventListener;
						    this.windowRemoveEventListener = win.removeEventListener || winProto.removeEventListener;
						    this.windowDispatchEvent = win.dispatchEvent;
						    this.WindowPointerEvent = win.PointerEvent || winProto.PointerEvent;
						    this.WindowMSPointerEvent = win.MSPointerEvent || winProto.MSPointerEvent;
						    this.WindowTouch = win.Touch || winProto.Touch;
						    this.WindowTouchEvent = win.TouchEvent || winProto.TouchEvent;
						    this.WindowKeyboardEvent = win.KeyboardEvent || winProto.KeyboardEvent;
						    this.WindowFocusEvent = win.FocusEvent || winProto.FocusEvent;
						    this.WindowTextEvent = win.TextEvent || winProto.TextEvent;
						    this.WindowInputEvent = win.InputEvent || winProto.InputEvent;
						    this.WindowMouseEvent = win.MouseEvent || winProto.MouseEvent;
						    this.canvasContextDrawImage = win.CanvasRenderingContext2D && win.CanvasRenderingContext2D.prototype.drawImage; // FormData

						    this.formDataAppend = win.FormData && win.FormData.prototype.append; // DateTime

						    this.date = win.Date;
						    this.dateNow = win.Date.now; // eslint-disable-line no-restricted-properties
						    // Math

						    this.math = win.Math;
						    this.mathRandom = win.Math.random; // Object

						    this.objectToString = win.Object.prototype.toString;
						    this.objectAssign = win.Object.assign;
						    this.objectKeys = win.Object.keys;
						    this.objectDefineProperty = win.Object.defineProperty;
						    this.objectDefineProperties = win.Object.defineProperties;
						    this.objectCreate = win.Object.create;
						    this.objectIsExtensible = win.Object.isExtensible;
						    this.objectIsFrozen = win.Object.isFrozen;
						    this.objectGetOwnPropertyDescriptor = win.Object.getOwnPropertyDescriptor;
						    this.objectHasOwnProperty = win.Object.hasOwnProperty;
						    this.objectGetOwnPropertyNames = win.Object.getOwnPropertyNames;
						    this.objectGetPrototypeOf = win.Object.getPrototypeOf;
						    this.objectGetOwnPropertySymbols = win.Object.getOwnPropertySymbols; // Array

						    this.arraySlice = win.Array.prototype.slice;
						    this.arrayConcat = win.Array.prototype.concat;
						    this.arrayFilter = win.Array.prototype.filter;
						    this.arrayMap = win.Array.prototype.map;
						    this.arrayJoin = win.Array.prototype.join;
						    this.arraySplice = win.Array.prototype.splice;
						    this.arrayForEach = win.Array.prototype.forEach;
						    this.arrayFrom = win.Array.from;
						    this.DOMParserParseFromString = win.DOMParser && win.DOMParser.prototype.parseFromString;
						    this.arrayBufferIsView = win.ArrayBuffer.prototype.constructor.isView; // NOTE: this section relates to getting properties from DOM classes

						    if (!isInWorker) {
						      // DOMTokenList
						      this.tokenListAdd = win.DOMTokenList.prototype.add;
						      this.tokenListRemove = win.DOMTokenList.prototype.remove;
						      this.tokenListReplace = win.DOMTokenList.prototype.replace;
						      this.tokenListSupports = win.DOMTokenList.prototype.supports;
						      this.tokenListToggle = win.DOMTokenList.prototype.toggle;
						      this.tokenListContains = win.DOMTokenList.prototype.contains;
						      var tokenListValueDescriptor = win.Object.getOwnPropertyDescriptor(win.DOMTokenList.prototype, 'value'); // NOTE: IE11 doesn't support the 'value' property of the DOMTokenList interface

						      if (tokenListValueDescriptor) this.tokenListValueSetter = tokenListValueDescriptor.set; // Stylesheets

						      this.styleGetPropertyValue = win.CSSStyleDeclaration.prototype.getPropertyValue;
						      this.styleSetProperty = win.CSSStyleDeclaration.prototype.setProperty;
						      this.styleRemoveProperty = win.CSSStyleDeclaration.prototype.removeProperty;
						      this.styleInsertRule = win.CSSStyleSheet.prototype.insertRule;
						      this.scrollTo = win.scrollTo;
						    }

						    if (win.Promise) {
						      this.promiseThen = win.Promise.prototype.then;
						      this.promiseReject = win.Promise.reject;
						    } // Console


						    this.console = win.console;

						    if (this.console) {
						      this.consoleMeths = {
						        log: win.console.log,
						        warn: win.console.warn,
						        error: win.console.error,
						        info: win.console.info
						      };
						    }

						    this.crypto = win.crypto || win.msCrypto;
						    this.cryptoGetRandomValues = this.crypto && this.crypto.getRandomValues;
						    this.refreshClasses(win);

						    this._refreshGettersAndSetters(win, isInWorker);
						  };

						  _proto.refreshClasses = function refreshClasses(win) {
						    this.windowClass = win.Window;
						    this.documentClass = win.Document;
						    this.locationClass = win.Location;
						    this.elementClass = win.Element;
						    this.svgElementClass = win.SVGElement;
						    this.Worker = win.Worker;
						    this.MessageChannel = win.MessageChannel;
						    this.ArrayBuffer = win.ArrayBuffer;
						    this.Uint8Array = win.Uint8Array;
						    this.Uint16Array = win.Uint16Array;
						    this.Uint32Array = win.Uint32Array;
						    this.DataView = win.DataView;
						    this.Blob = win.Blob;
						    this.XMLHttpRequest = win.XMLHttpRequest;
						    this.Image = win.Image;
						    this.Function = win.Function;
						    this.functionToString = win.Function.prototype.toString;
						    this.Error = win.Error;
						    this.FontFace = win.FontFace;
						    this.StorageEvent = win.StorageEvent;
						    this.MutationObserver = win.MutationObserver;
						    this.EventSource = win.EventSource;
						    this.Proxy = win.Proxy;
						    this.WebSocket = win.WebSocket;
						    this.HTMLCollection = win.HTMLCollection;
						    this.NodeList = win.NodeList;
						    this.Node = win.Node;
						    this.URL = win.URL;
						    this.DataTransfer = win.DataTransfer;
						    this.DataTransferItemList = win.DataTransferItemList;
						    this.DataTransferItem = win.DataTransferItem;
						    this.FileList = win.FileList; // NOTE: non-IE11 case. window.File in IE11 is not constructable.

						    if (win.File && typeof win.File === 'function') this.File = win.File;
						  };

						  _proto.refreshElectronMeths = function refreshElectronMeths(vmModule) {
						    if (this.createScript && overriding_1.isNativeFunction(vmModule.createScript)) return false;
						    this.createScript = vmModule.createScript;
						    this.runInDebugContext = vmModule.runInDebugContext;
						    this.runInContext = vmModule.runInContext;
						    this.runInNewContext = vmModule.runInNewContext;
						    this.runInThisContext = vmModule.runInThisContext;
						    return true;
						  };

						  NativeMethods._ensureDocumentMethodRestore = function _ensureDocumentMethodRestore(document, prototype, methodName, savedNativeMethod) {
						    prototype[methodName] = savedNativeMethod;
						    if (document[methodName] !== prototype[methodName]) document[methodName] = savedNativeMethod;
						  };

						  _proto.restoreDocumentMeths = function restoreDocumentMeths(window, document) {
						    var docPrototype = window.Document.prototype;

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createDocumentFragment', this.createDocumentFragment);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createElement', this.createElement);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createElementNS', this.createElementNS);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'elementFromPoint', this.elementFromPoint);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'caretRangeFromPoint', this.caretRangeFromPoint);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'caretPositionFromPoint', this.caretPositionFromPoint);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'getElementById', this.getElementById);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'getElementsByClassName', this.getElementsByClassName);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'getElementsByName', this.getElementsByName);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'getElementsByTagName', this.getElementsByTagName);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'querySelector', this.querySelector);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'querySelectorAll', this.querySelectorAll); // Event
						    // NOTE: IE11 has no EventTarget


						    if (!window.EventTarget) {
						      NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'addEventListener', this.documentAddEventListener);

						      NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'removeEventListener', this.documentRemoveEventListener);
						    }

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createEvent', this.documentCreateEvent);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createTouch', this.documentCreateTouch);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createTouchList', this.documentCreateTouchList);

						    NativeMethods._ensureDocumentMethodRestore(document, window[this.documentOpenPropOwnerName].prototype, 'open', this.documentOpen);

						    NativeMethods._ensureDocumentMethodRestore(document, window[this.documentClosePropOwnerName].prototype, 'close', this.documentClose);

						    NativeMethods._ensureDocumentMethodRestore(document, window[this.documentWritePropOwnerName].prototype, 'write', this.documentWrite);

						    NativeMethods._ensureDocumentMethodRestore(document, window[this.documentWriteLnPropOwnerName].prototype, 'writeln', this.documentWriteLn);
						  };

						  _proto.refreshIfNecessary = function refreshIfNecessary(doc, win) {
						    var _this2 = this;

						    var tryToExecuteCode = function tryToExecuteCode(func) {
						      try {
						        return func();
						      } catch (e) {
						        return true;
						      }
						    };

						    var needToRefreshDocumentMethods = tryToExecuteCode(function () {
						      return !doc.createElement || overriding_1.isNativeFunction(document.createElement);
						    });
						    var needToRefreshElementMethods = tryToExecuteCode(function () {
						      var nativeElement = _this2.createElement.call(doc, 'div');

						      return overriding_1.isNativeFunction(nativeElement.getAttribute);
						    });
						    var needToRefreshWindowMethods = tryToExecuteCode(function () {
						      _this2.setTimeout.call(win, function () {
						        return void 0;
						      }, 0);

						      return overriding_1.isNativeFunction(win.XMLHttpRequest.prototype.open);
						    }); // NOTE: T173709

						    if (needToRefreshDocumentMethods) this.refreshDocumentMeths(doc, win);
						    if (needToRefreshElementMethods) this.refreshElementMeths(doc, win); // NOTE: T239109

						    if (needToRefreshWindowMethods) this.refreshWindowMeths(win);
						  };

						  _proto.isNativeCode = function isNativeCode(fn) {
						    return NATIVE_CODE_RE.test(fn.toString());
						  };

						  return NativeMethods;
						}();

						exports.default = new NativeMethods();
						module.exports = exports.default;
					},
					"xhr.js": function (exports, module, require) {
						

						function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

						function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var sandbox_base_with_delayed_settings_1 = __importDefault(require("../worker/sandbox-base-with-delayed-settings"));

						var native_methods_1 = __importDefault(require("./native-methods"));

						var url_1 = require("../utils/url");

						var builtin_header_names_1 = __importDefault(require("../../request-pipeline/builtin-header-names"));

						var overriding_1 = require("../utils/overriding");

						var url_2 = require("../../utils/url");

						var headers_1 = require("../../utils/headers");

						var XHR_READY_STATES = ['UNSENT', 'OPENED', 'HEADERS_RECEIVED', 'LOADING', 'DONE'];

						var XhrSandbox = /*#__PURE__*/function (_sandbox_base_with_de) {
						  _inheritsLoose(XhrSandbox, _sandbox_base_with_de);

						  function XhrSandbox(_cookieSandbox, waitHammerheadSettings) {
						    var _this;

						    _this = _sandbox_base_with_de.call(this, waitHammerheadSettings) || this;
						    _this._cookieSandbox = _cookieSandbox;
						    _this.XHR_COMPLETED_EVENT = 'hammerhead|event|xhr-completed';
						    _this.XHR_ERROR_EVENT = 'hammerhead|event|xhr-error';
						    _this.BEFORE_XHR_SEND_EVENT = 'hammerhead|event|before-xhr-send';
						    return _this;
						  }

						  XhrSandbox.createNativeXHR = function createNativeXHR() {
						    var xhr = new native_methods_1.default.XMLHttpRequest();
						    xhr.open = native_methods_1.default.xhrOpen;
						    xhr.abort = native_methods_1.default.xhrAbort;
						    xhr.send = native_methods_1.default.xhrSend;
						    xhr.addEventListener = native_methods_1.default.xhrAddEventListener || native_methods_1.default.addEventListener;
						    xhr.removeEventListener = native_methods_1.default.xhrRemoveEventListener || native_methods_1.default.removeEventListener;
						    xhr.setRequestHeader = native_methods_1.default.xhrSetRequestHeader;
						    xhr.getResponseHeader = native_methods_1.default.xhrGetResponseHeader;
						    xhr.getAllResponseHeaders = native_methods_1.default.xhrGetAllResponseHeaders;
						    xhr.overrideMimeType = native_methods_1.default.xhrOverrideMimeType;
						    xhr.dispatchEvent = native_methods_1.default.xhrDispatchEvent || native_methods_1.default.dispatchEvent;
						    return xhr;
						  };

						  XhrSandbox.openNativeXhr = function openNativeXhr(xhr, url, isAsync) {
						    xhr.open('POST', url, isAsync);
						    xhr.setRequestHeader(builtin_header_names_1.default.cacheControl, 'no-cache, no-store, must-revalidate');
						  };

						  XhrSandbox._reopenXhr = function _reopenXhr(xhr, reqOpts) {
						    var url = reqOpts.openArgs[1];
						    var withCredentials = xhr.withCredentials;
						    reqOpts.withCredentials = withCredentials;
						    reqOpts.openArgs[1] = url_1.getAjaxProxyUrl(url, withCredentials ? url_2.Credentials.include : url_2.Credentials.sameOrigin);
						    native_methods_1.default.xhrOpen.apply(xhr, reqOpts.openArgs);
						    reqOpts.openArgs[1] = url;

						    for (var _i2 = 0, _reqOpts$headers2 = reqOpts.headers; _i2 < _reqOpts$headers2.length; _i2++) {
						      var header = _reqOpts$headers2[_i2];
						      native_methods_1.default.xhrSetRequestHeader.apply(xhr, header);
						    }
						  };

						  var _proto = XhrSandbox.prototype;

						  _proto.attach = function attach(window) {
						    _sandbox_base_with_de.prototype.attach.call(this, window);

						    var xhrSandbox = this;
						    var xmlHttpRequestProto = window.XMLHttpRequest.prototype;

						    var emitXhrCompletedEvent = function emitXhrCompletedEvent() {
						      var nativeRemoveEventListener = native_methods_1.default.xhrRemoveEventListener || native_methods_1.default.removeEventListener;
						      xhrSandbox.emit(xhrSandbox.XHR_COMPLETED_EVENT, {
						        xhr: this
						      });
						      nativeRemoveEventListener.call(this, 'loadend', emitXhrCompletedEvent);
						    };

						    var syncCookieWithClientIfNecessary = function syncCookieWithClientIfNecessary() {
						      if (this.readyState < this.HEADERS_RECEIVED) return;
						      var nativeRemoveEventListener = native_methods_1.default.xhrRemoveEventListener || native_methods_1.default.removeEventListener;

						      xhrSandbox._cookieSandbox.syncCookie();

						      nativeRemoveEventListener.call(this, 'readystatechange', syncCookieWithClientIfNecessary);
						    };

						    var xmlHttpRequestWrapper = function xmlHttpRequestWrapper() {
						      var nativeAddEventListener = native_methods_1.default.xhrAddEventListener || native_methods_1.default.addEventListener;
						      var xhr = new native_methods_1.default.XMLHttpRequest();
						      nativeAddEventListener.call(xhr, 'loadend', emitXhrCompletedEvent);
						      nativeAddEventListener.call(xhr, 'readystatechange', syncCookieWithClientIfNecessary);
						      return xhr;
						    };

						    for (var _i4 = 0; _i4 < XHR_READY_STATES.length; _i4++) {
						      var readyState = XHR_READY_STATES[_i4];
						      native_methods_1.default.objectDefineProperty(xmlHttpRequestWrapper, readyState, native_methods_1.default.objectGetOwnPropertyDescriptor(native_methods_1.default.XMLHttpRequest, readyState));
						    } // NOTE: We cannot just assign constructor property of the prototype of XMLHttpRequest starts from safari 9.0


						    overriding_1.overrideConstructor(window, 'XMLHttpRequest', xmlHttpRequestWrapper);
						    native_methods_1.default.objectDefineProperty(xmlHttpRequestProto, 'constructor', {
						      value: xmlHttpRequestWrapper
						    });
						    overriding_1.overrideFunction(xmlHttpRequestProto, 'abort', function () {
						      var _this2 = this;

						      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
						        args[_key] = arguments[_key];
						      }

						      if (xhrSandbox.gettingSettingInProgress()) return void xhrSandbox.delayUntilGetSettings(function () {
						        return _this2.abort.apply(_this2, args);
						      });
						      native_methods_1.default.xhrAbort.apply(this, args);
						      xhrSandbox.emit(xhrSandbox.XHR_ERROR_EVENT, {
						        err: new Error('XHR aborted'),
						        xhr: this
						      });
						    }); // NOTE: Redirect all requests to the Hammerhead proxy and ensure that requests don't
						    // violate Same Origin Policy.

						    overriding_1.overrideFunction(xmlHttpRequestProto, 'open', function () {
						      var _this3 = this;

						      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
						        args[_key2] = arguments[_key2];
						      }

						      var url = args[1];
						      if (url_1.getProxyUrl(url) === url) return void native_methods_1.default.xhrOpen.apply(this, args);
						      if (xhrSandbox.gettingSettingInProgress()) return void xhrSandbox.delayUntilGetSettings(function () {
						        return _this3.open.apply(_this3, args);
						      });
						      url = typeof url === 'string' ? url : String(url);
						      args[1] = url_1.getAjaxProxyUrl(url, this.withCredentials ? url_2.Credentials.include : url_2.Credentials.sameOrigin);
						      native_methods_1.default.xhrOpen.apply(this, args);
						      args[1] = url;
						      XhrSandbox.REQUESTS_OPTIONS.set(this, {
						        withCredentials: this.withCredentials,
						        openArgs: args,
						        headers: []
						      });
						    });
						    overriding_1.overrideFunction(xmlHttpRequestProto, 'send', function () {
						      var _this4 = this;

						      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
						        args[_key3] = arguments[_key3];
						      }

						      if (xhrSandbox.gettingSettingInProgress()) return void xhrSandbox.delayUntilGetSettings(function () {
						        return _this4.send.apply(_this4, args);
						      });
						      var reqOpts = XhrSandbox.REQUESTS_OPTIONS.get(this);
						      if (reqOpts.withCredentials !== this.withCredentials) XhrSandbox._reopenXhr(this, reqOpts);
						      xhrSandbox.emit(xhrSandbox.BEFORE_XHR_SEND_EVENT, {
						        xhr: this
						      });
						      native_methods_1.default.xhrSend.apply(this, args); // NOTE: For xhr with the sync mode

						      if (this.readyState === this.DONE) emitXhrCompletedEvent.call(this);
						      syncCookieWithClientIfNecessary.call(this);
						    });
						    overriding_1.overrideFunction(xmlHttpRequestProto, 'setRequestHeader', function () {
						      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
						        args[_key4] = arguments[_key4];
						      }

						      if (headers_1.isAuthorizationHeader(args[0])) args[1] = headers_1.addAuthorizationPrefix(args[1]);
						      native_methods_1.default.xhrSetRequestHeader.apply(this, args);
						      var reqOpts = XhrSandbox.REQUESTS_OPTIONS.get(this);
						      if (reqOpts) reqOpts.headers.push([String(args[0]), String(args[1])]);
						    });

						    if (native_methods_1.default.xhrResponseURLGetter) {
						      overriding_1.overrideDescriptor(window.XMLHttpRequest.prototype, 'responseURL', {
						        getter: function getter() {
						          return url_1.getDestinationUrl(native_methods_1.default.xhrResponseURLGetter.call(this));
						        }
						      });
						    }

						    overriding_1.overrideFunction(xmlHttpRequestProto, 'getResponseHeader', function () {
						      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
						        args[_key5] = arguments[_key5];
						      }

						      var value = native_methods_1.default.xhrGetResponseHeader.apply(this, args);
						      if (value && headers_1.isAuthenticateHeader(args[0])) value = headers_1.removeAuthenticatePrefix(value);
						      return value;
						    });
						    overriding_1.overrideFunction(xmlHttpRequestProto, 'getAllResponseHeaders', function () {
						      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
						        args[_key6] = arguments[_key6];
						      }

						      var allHeaders = native_methods_1.default.xhrGetAllResponseHeaders.apply(this, args);

						      while (headers_1.hasAuthenticatePrefix(allHeaders)) {
						        allHeaders = headers_1.removeAuthenticatePrefix(allHeaders);
						      }

						      return allHeaders;
						    });
						  };

						  return XhrSandbox;
						}(sandbox_base_with_delayed_settings_1.default);

						exports.default = XhrSandbox;
						XhrSandbox.REQUESTS_OPTIONS = new WeakMap();
						module.exports = exports.default;
					}
				},
				"settings.js": function (exports, module, require) {
					

					Object.defineProperty(exports, "__esModule", {
					  value: true
					});

					var Settings = /*#__PURE__*/function () {
					  function Settings() {
					    this._settings = {
					      isFirstPageLoad: true,
					      sessionId: '',
					      forceProxySrcForImage: false,
					      crossDomainProxyPort: '',
					      referer: '',
					      serviceMsgUrl: '',
					      transportWorkerUrl: '',
					      iframeTaskScriptTemplate: '',
					      cookie: '',
					      allowMultipleWindows: false,
					      isRecordMode: false,
					      windowId: ''
					    };
					  }

					  var _proto = Settings.prototype;

					  _proto.set = function set(value) {
					    this._settings = value;
					  };

					  _proto.get = function get() {
					    return this._settings;
					  };

					  return Settings;
					}();

					var settings = new Settings();
					exports.default = settings;
					module.exports = exports.default;
				},
				"utils": {
					"browser.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var bowser_1 = __importDefault(require("bowser"));

						var userAgent = navigator.userAgent.toLowerCase(); //@ts-ignore

						var info = bowser_1.default._detect(userAgent);

						var webkitVersionMatch = userAgent.match(/applewebkit\/(\d+(:?\.\d+)*)/); //Helper
						//@ts-ignore

						exports.compareVersions = bowser_1.default.compareVersions; //Platforms

						exports.isMacPlatform = !!info.mac;
						exports.isAndroid = !!info.android;
						exports.isIOS = !!info.ios;
						exports.isMobile = !!info.mobile;
						exports.isTablet = !!info.tablet; //Browsers

						exports.version = parseInt(info.version, 10);
						exports.fullVersion = info.version;
						exports.webkitVersion = webkitVersionMatch && webkitVersionMatch[1] || '';
						exports.isIE = !!(info.msie || info.msedge);
						exports.isIE11 = exports.isIE && exports.version === 11;
						exports.isIE10 = exports.isIE && exports.version === 10;
						exports.isIE9 = exports.isIE && exports.version === 9;
						exports.isFirefox = !!info.firefox;
						exports.isMSEdge = !!info.msedge;
						exports.isChrome = !!info.chrome;
						exports.isSafari = !!info.safari;
						exports.isWebKit = !!(info.webkit || info.blink);
						exports.isElectron = /electron/g.test(userAgent);
					},
					"destination-location.js": function (exports, module, require) {
						

						var __importStar = void 0 && (void 0).__importStar || function (mod) {
						  if (mod && mod.__esModule) return mod;
						  var result = {};
						  if (mod != null) for (var k in mod) {
						    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
						  }
						  result["default"] = mod;
						  return result;
						};

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var sharedUrlUtils = __importStar(require("../../utils/url"));

						var domUtils = __importStar(require("./dom"));

						var urlResolver = __importStar(require("./url-resolver"));

						var settings_1 = __importDefault(require("../settings"));

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var global_context_info_1 = __importDefault(require("./global-context-info"));

						var forcedLocation = null; // NOTE: exposed only for tests

						function getLocation() {
						  // NOTE: Used for testing. Unfortunately, we cannot override the 'getLocation' method in a test.
						  if (forcedLocation) return forcedLocation;
						  var frameElement = domUtils.getFrameElement(global_context_info_1.default.global); // NOTE: Fallback to the owner page's URL if we are in an iframe without src.

						  if (frameElement && domUtils.isIframeWithoutSrc(frameElement)) return settings_1.default.get().referer;
						  return global_context_info_1.default.global.location.toString();
						}

						exports.getLocation = getLocation; // NOTE: We need to be able to force the page location. During the test, Hammerhead should think that it is on the
						// proxied page, not in the test environment. Unfortunately, we cannot do it in any other way.

						function forceLocation(url) {
						  forcedLocation = url;
						}

						exports.forceLocation = forceLocation;

						function sameOriginCheck(location, checkedUrl) {
						  if (checkedUrl) checkedUrl = resolveUrl(checkedUrl);
						  return sharedUrlUtils.sameOriginCheck(location, checkedUrl);
						}

						exports.sameOriginCheck = sameOriginCheck;

						function resolveUrl(url, doc) {
						  var preProcessedUrl = sharedUrlUtils.getURLString(url);

						  if (preProcessedUrl && preProcessedUrl.indexOf('//') === 0) {
						    // eslint-disable-next-line no-restricted-properties
						    var pageProtocol = getParsed().protocol;
						    preProcessedUrl = pageProtocol + sharedUrlUtils.correctMultipleSlashes(preProcessedUrl, pageProtocol);
						  } else preProcessedUrl = sharedUrlUtils.correctMultipleSlashes(preProcessedUrl);

						  if (global_context_info_1.default.isInWorker) {
						    if (self.location.protocol !== 'blob:') // eslint-disable-line no-restricted-properties
						      return new native_methods_1.default.URL(preProcessedUrl, get()).href; // eslint-disable-line no-restricted-properties
						    else return url;
						  } else {
						    // @ts-ignore
						    return urlResolver.resolve(preProcessedUrl, doc || document);
						  }
						}

						exports.resolveUrl = resolveUrl;

						function get() {
						  var location = getLocation();
						  var parsedProxyUrl = sharedUrlUtils.parseProxyUrl(location);
						  return parsedProxyUrl ? parsedProxyUrl.destUrl : location;
						}

						exports.get = get;

						function withHash(hash) {
						  var location = get(); // NOTE: Remove the previous hash if there is any.

						  location = location.replace(/(#.*)$/, '');
						  return location + hash;
						}

						exports.withHash = withHash;

						function parseLocationThroughAnchor(url) {
						  // @ts-ignore
						  var resolver = urlResolver.getResolverElement(document); // eslint-disable-next-line no-restricted-properties

						  var destPort = sharedUrlUtils.parseUrl(url).port; // NOTE: IE browser adds the default port for the https protocol while resolving.

						  native_methods_1.default.anchorHrefSetter.call(resolver, get());
						  var hostname = native_methods_1.default.anchorHostnameGetter.call(resolver);
						  var pathname = native_methods_1.default.anchorPathnameGetter.call(resolver); // NOTE: IE ignores the first '/' symbol in the pathname.

						  if (pathname.charAt(0) !== '/') pathname = '/' + pathname; // TODO: Describe default ports logic.

						  return {
						    protocol: native_methods_1.default.anchorProtocolGetter.call(resolver),
						    // NOTE: Remove the default port.
						    port: destPort ? native_methods_1.default.anchorPortGetter.call(resolver) : '',
						    hostname: hostname,
						    // NOTE: Remove the default port from the host.
						    host: destPort ? native_methods_1.default.anchorHostGetter.call(resolver) : hostname,
						    pathname: pathname,
						    hash: resolver.hash,
						    search: native_methods_1.default.anchorSearchGetter.call(resolver)
						  };
						}

						function parseLocationThroughURL(url) {
						  var parsedUrl = new native_methods_1.default.URL(url);
						  /* eslint-disable no-restricted-properties */

						  return {
						    protocol: parsedUrl.protocol,
						    port: parsedUrl.port,
						    hostname: parsedUrl.hostname,
						    host: parsedUrl.host,
						    pathname: parsedUrl.pathname,
						    hash: parsedUrl.hash,
						    search: parsedUrl.search
						  };
						  /* eslint-enable no-restricted-properties */
						}

						function getParsed() {
						  var dest = get();
						  return global_context_info_1.default.isInWorker ? parseLocationThroughURL(dest) : parseLocationThroughAnchor(dest);
						}

						exports.getParsed = getParsed;

						function getOriginHeader() {
						  return sharedUrlUtils.getDomain(getParsed());
						}

						exports.getOriginHeader = getOriginHeader;
					},
					"dom.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						var __importStar = void 0 && (void 0).__importStar || function (mod) {
						  if (mod && mod.__esModule) return mod;
						  var result = {};
						  if (mod != null) for (var k in mod) {
						    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
						  }
						  result["default"] = mod;
						  return result;
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var internal_attributes_1 = __importDefault(require("../../processing/dom/internal-attributes"));

						var internal_properties_1 = __importDefault(require("../../processing/dom/internal-properties"));

						var class_name_1 = __importDefault(require("../../shadow-ui/class-name"));

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var urlUtils = __importStar(require("./url"));

						var style_1 = require("./style");

						var destination_location_1 = require("./destination-location");

						var browser_1 = require("./browser");

						var query_selector_1 = require("./query-selector");

						var feature_detection_1 = require("./feature-detection");

						var scrollbarSize = 0;
						var NATIVE_MAP_ELEMENT_STRINGS = ['[object HTMLMapElement]', '[object HTMLAreaElement]'];
						var WINDOW_IS_UNDEFINED = typeof window === 'undefined';
						var NATIVE_WINDOW_STR = WINDOW_IS_UNDEFINED ? '' : instanceToString(window);
						var IS_DOCUMENT_RE = /^\[object .*?Document]$/i;
						var IS_PROCESSING_INSTRUCTION_RE = /^\[object .*?ProcessingInstruction]$/i;
						var IS_SVG_ELEMENT_RE = /^\[object SVG\w+?Element]$/i;
						var IS_HTML_ELEMENT_RE = /^\[object HTML.*?Element]$/i;
						var IS_ARRAY_BUFFER_RE = /^\[object ArrayBuffer]$/i;
						var IS_DATA_VIEW_RE = /^\[object DataView]$/i;
						var NATIVE_TABLE_CELL_STR = WINDOW_IS_UNDEFINED ? '' : instanceToString(native_methods_1.default.createElement.call(document, 'td'));
						var ELEMENT_NODE_TYPE = WINDOW_IS_UNDEFINED ? -1 : Node.ELEMENT_NODE;
						var NOT_CONTENT_EDITABLE_ELEMENTS_RE = /^(select|option|applet|area|audio|canvas|datalist|keygen|map|meter|object|progress|source|track|video|img)$/;
						var INPUT_ELEMENTS_RE = /^(input|textarea|button)$/;
						var SCRIPT_OR_STYLE_RE = /^(script|style)$/i;
						var EDITABLE_INPUT_TYPES_RE = /^(email|number|password|search|tel|text|url)$/;
						var NUMBER_OR_EMAIL_INPUT_RE = /^(number|email)$/; // NOTE: input with 'file' type processed separately in 'UploadSandbox'

						var INPUT_WITH_NATIVE_DIALOG = /^(color|date|datetime-local|month|week)$/; // NOTE: We don't take into account the case of embedded contentEditable elements, and we
						// specify the contentEditable attribute for focusable elements.

						var FOCUSABLE_SELECTOR = 'input, select, textarea, button, body, iframe, [contenteditable="true"], [contenteditable=""], [tabIndex]';

						function isHidden(el) {
						  return el.offsetWidth <= 0 && el.offsetHeight <= 0;
						}

						function isAlwaysNotEditableElement(el) {
						  var tagName = getTagName(el);
						  return !!tagName && (NOT_CONTENT_EDITABLE_ELEMENTS_RE.test(tagName) || INPUT_ELEMENTS_RE.test(tagName));
						}

						function isLocationByProto(instance) {
						  var instanceCtor = null;

						  try {
						    // eslint-disable-next-line no-proto
						    instanceCtor = instance.__proto__;
						  } catch (e) {
						    // NOTE: Try to detect cross-domain window location.
						    // A cross-domain location has no the "assign" function in Safari and Chrome.
						    var shouldNotHaveAssign = browser_1.isSafari || browser_1.isChrome;
						    return instance.replace && (shouldNotHaveAssign || !!instance.assign);
						  }

						  if (!instanceCtor) return false;
						  var stringifiedInstanceCtor = native_methods_1.default.objectToString.call(instanceCtor);
						  return stringifiedInstanceCtor === '[object LocationPrototype]' || stringifiedInstanceCtor === '[object Location]'; // NOTE: "iPhone" Chrome device emulation case (GH-2080)
						}

						function closestFallback(el, selector) {
						  while (el) {
						    if (matches(el, selector)) return el;
						    el = native_methods_1.default.nodeParentNodeGetter.call(el);
						  }

						  return null;
						}

						function instanceToString(instance) {
						  if (!feature_detection_1.instanceAndPrototypeToStringAreEqual) return native_methods_1.default.objectToString.call(instance);
						  return instance && typeof instance === 'object' ? native_methods_1.default.objectToString.call(native_methods_1.default.objectGetPrototypeOf(instance)) : '';
						}

						exports.instanceToString = instanceToString;

						function getActiveElement(currentDocument) {
						  // NOTE: Sometimes document.activeElement returns an empty object or null (IE11).
						  // https://github.com/DevExpress/testcafe-hammerhead/issues/768
						  var doc = currentDocument || document;
						  var activeElement = native_methods_1.default.documentActiveElementGetter.call(doc);
						  var el = isDomElement(activeElement) ? activeElement : doc.body;

						  while (el && el.shadowRoot) {
						    // eslint-disable-next-line no-restricted-properties
						    var shadowEl = el.shadowRoot.activeElement;
						    if (!shadowEl) break;
						    el = shadowEl;
						  }

						  return el;
						}

						exports.getActiveElement = getActiveElement;

						function getChildVisibleIndex(select, child) {
						  var childrenArray = getSelectVisibleChildren(select);
						  return childrenArray.indexOf(child);
						}

						exports.getChildVisibleIndex = getChildVisibleIndex;

						function getIframeByElement(el) {
						  var elWindow = el[internal_properties_1.default.processedContext];
						  return getFrameElement(elWindow);
						}

						exports.getIframeByElement = getIframeByElement;

						function getIframeLocation(iframe) {
						  var documentLocation = null;

						  try {
						    // eslint-disable-next-line no-restricted-properties
						    documentLocation = native_methods_1.default.contentDocumentGetter.call(iframe).location.href;
						  } catch (e) {
						    documentLocation = null;
						  }

						  var srcLocation = native_methods_1.default.getAttribute.call(iframe, 'src' + internal_attributes_1.default.storedAttrPostfix) || native_methods_1.default.getAttribute.call(iframe, 'src') || native_methods_1.default.iframeSrcGetter.call(iframe);
						  var parsedProxyDocumentLocation = documentLocation && urlUtils.isSupportedProtocol(documentLocation) && urlUtils.parseProxyUrl(documentLocation);
						  var parsedProxySrcLocation = srcLocation && urlUtils.isSupportedProtocol(srcLocation) && urlUtils.parseProxyUrl(srcLocation);
						  return {
						    documentLocation: parsedProxyDocumentLocation ? parsedProxyDocumentLocation.destUrl : documentLocation,
						    srcLocation: parsedProxySrcLocation ? parsedProxySrcLocation.destUrl : srcLocation
						  };
						}

						exports.getIframeLocation = getIframeLocation;

						function getFrameElement(win) {
						  try {
						    return win.frameElement;
						  } catch (e) {
						    return null;
						  }
						}

						exports.getFrameElement = getFrameElement;

						function getMapContainer(el) {
						  var closestMap = closest(el, 'map');
						  var closestMapName = native_methods_1.default.getAttribute.call(closestMap, 'name');
						  var containerSelector = '[usemap="#' + closestMapName + '"]';
						  return native_methods_1.default.querySelector.call(findDocument(el), containerSelector);
						}

						exports.getMapContainer = getMapContainer;

						function getParentWindowWithSrc(window) {
						  var parent = window.parent;
						  var parentFrameElement = null;
						  if (window === window.top) return window;
						  if (parent === window.top || isCrossDomainWindows(window, parent)) return parent;

						  try {
						    parentFrameElement = parent.frameElement;
						  } catch (e) {
						    parentFrameElement = null;
						  }

						  if (parentFrameElement === null || !isIframeWithoutSrc(parentFrameElement)) return parent;
						  return getParentWindowWithSrc(parent);
						}

						exports.getParentWindowWithSrc = getParentWindowWithSrc;

						function getScrollbarSize() {
						  if (!scrollbarSize) {
						    var scrollDiv = native_methods_1.default.createElement.call(document, 'div');
						    scrollDiv.style.height = '100px';
						    scrollDiv.style.overflow = 'scroll';
						    scrollDiv.style.position = 'absolute';
						    scrollDiv.style.top = '-9999px';
						    scrollDiv.style.width = '100px';
						    native_methods_1.default.appendChild.call(document.body, scrollDiv);
						    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
						    scrollbarSize = scrollbarWidth;
						    var parent = native_methods_1.default.nodeParentNodeGetter.call(scrollDiv);
						    parent.removeChild(scrollDiv);
						  }

						  return scrollbarSize;
						}

						exports.getScrollbarSize = getScrollbarSize;

						function getSelectParent(child) {
						  var parent = native_methods_1.default.nodeParentNodeGetter.call(child);
						  return closest(parent, 'select');
						}

						exports.getSelectParent = getSelectParent;

						function getSelectVisibleChildren(select) {
						  var children = native_methods_1.default.elementQuerySelectorAll.call(select, 'optgroup, option');
						  var result = [];
						  var length = native_methods_1.default.nodeListLengthGetter.call(children);

						  for (var i = 0; i < length; i++) {
						    var child = children[i]; // NOTE: Firefox does not display groups without a label and with an empty label.

						    var shouldAdd = browser_1.isFirefox ? getTagName(child) !== 'optgroup' || child.label : true;
						    if (shouldAdd) result.push(child);
						  }

						  return result;
						}

						exports.getSelectVisibleChildren = getSelectVisibleChildren;

						function getTopSameDomainWindow(window) {
						  var result = window;
						  var currentWindow = window.parent;
						  if (result === window.top) return result;

						  while (currentWindow) {
						    if (!isCrossDomainWindows(window, currentWindow)) {
						      var frameElement = getFrameElement(currentWindow);
						      if (!frameElement || !isIframeWithoutSrc(frameElement)) result = currentWindow;
						    }

						    currentWindow = currentWindow !== window.top ? currentWindow.parent : null;
						  }

						  return result;
						}

						exports.getTopSameDomainWindow = getTopSameDomainWindow;

						function find(parent, selector, handler) {
						  var nodeList = query_selector_1.getNativeQuerySelectorAll(parent).call(parent, selector);

						  if (handler) {
						    var length = native_methods_1.default.nodeListLengthGetter.call(nodeList);

						    for (var i = 0; i < length; i++) {
						      handler(nodeList[i]);
						    }
						  }

						  return nodeList;
						}

						exports.find = find;

						function findDocument(el) {
						  if (el.documentElement) return el;
						  if (el.ownerDocument && el.ownerDocument.defaultView) return el.ownerDocument;
						  var parent = isElementNode(el) && native_methods_1.default.nodeParentNodeGetter.call(el);
						  return parent ? findDocument(parent) : document;
						}

						exports.findDocument = findDocument;

						function isContentEditableElement(el) {
						  var isContentEditable = false;
						  var element = null;
						  if (isTextNode(el)) element = el.parentElement || native_methods_1.default.nodeParentNodeGetter.call(el);else element = el;

						  if (element) {
						    isContentEditable = element.isContentEditable && !isAlwaysNotEditableElement(element);
						    return isRenderedNode(element) && (isContentEditable || findDocument(el).designMode === 'on');
						  }

						  return false;
						}

						exports.isContentEditableElement = isContentEditableElement;

						function isCrossDomainIframe(iframe, bySrc) {
						  var iframeLocation = getIframeLocation(iframe);
						  if (!bySrc && iframeLocation.documentLocation === null) return true;
						  var currentLocation = bySrc ? iframeLocation.srcLocation : iframeLocation.documentLocation;
						  if (currentLocation && urlUtils.isSupportedProtocol(currentLocation)) return !destination_location_1.sameOriginCheck(location.toString(), currentLocation);
						  return false;
						}

						exports.isCrossDomainIframe = isCrossDomainIframe;

						function isCrossDomainWindows(window1, window2) {
						  try {
						    if (window1 === window2) return false;
						    var window1Location = window1.location.toString();
						    var window2Location = window2.location.toString();
						    if (!urlUtils.isSupportedProtocol(window1Location) || !urlUtils.isSupportedProtocol(window2Location)) return false;
						    return !destination_location_1.sameOriginCheck(window1Location, window2Location);
						  } catch (e) {
						    return true;
						  }
						}

						exports.isCrossDomainWindows = isCrossDomainWindows;

						function isIframeWindow(wnd) {
						  return wnd !== wnd.top;
						}

						exports.isIframeWindow = isIframeWindow;

						function isDomElement(el) {
						  if (el instanceof native_methods_1.default.elementClass) return true;
						  return el && IS_HTML_ELEMENT_RE.test(instanceToString(el)) && isElementNode(el) && el.tagName;
						}

						exports.isDomElement = isDomElement;

						function getTagName(el) {
						  // NOTE: Check for tagName being a string, because it may be a function in an Angular app (T175340).
						  return el && typeof el.tagName === 'string' ? el.tagName.toLowerCase() : '';
						}

						exports.getTagName = getTagName;
						exports.SHADOW_ROOT_PARENT_ELEMENT = 'hammerhead|element|shadow-root-parent';

						function getNodeShadowRootParent(el) {
						  var parent = native_methods_1.default.nodeParentNodeGetter.call(el);

						  while (parent && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
						    parent = native_methods_1.default.nodeParentNodeGetter.call(parent);
						  }

						  return parent && parent[exports.SHADOW_ROOT_PARENT_ELEMENT];
						}

						exports.getNodeShadowRootParent = getNodeShadowRootParent;

						function getParentExceptShadowRoot(el) {
						  var parent = native_methods_1.default.nodeParentNodeGetter.call(el);
						  return parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE && parent[exports.SHADOW_ROOT_PARENT_ELEMENT] ? parent[exports.SHADOW_ROOT_PARENT_ELEMENT] : parent;
						}

						exports.getParentExceptShadowRoot = getParentExceptShadowRoot;

						function isElementInDocument(el, currentDocument) {
						  var doc = currentDocument || document;
						  if (!doc.documentElement) return false;
						  if (doc.documentElement.contains(el)) return true;
						  var shadowRootParent = getNodeShadowRootParent(el);
						  return shadowRootParent ? isElementInDocument(shadowRootParent) : false;
						}

						exports.isElementInDocument = isElementInDocument;

						function isElementInIframe(el, currentDocument) {
						  var doc = currentDocument || findDocument(el);
						  return window.document !== doc;
						}

						exports.isElementInIframe = isElementInIframe;

						function isHammerheadAttr(attr) {
						  return attr === internal_attributes_1.default.focusPseudoClass || attr === internal_attributes_1.default.hoverPseudoClass || attr.indexOf(internal_attributes_1.default.storedAttrPostfix) !== -1;
						}

						exports.isHammerheadAttr = isHammerheadAttr;

						function isIframeElement(el) {
						  return instanceToString(el) === '[object HTMLIFrameElement]';
						}

						exports.isIframeElement = isIframeElement;

						function isFrameElement(el) {
						  return instanceToString(el) === '[object HTMLFrameElement]';
						}

						exports.isFrameElement = isFrameElement;

						function isIframeWithoutSrc(iframe) {
						  var iframeLocation = getIframeLocation(iframe);
						  var iframeSrcLocation = iframeLocation.srcLocation;
						  var iframeDocumentLocation = iframeLocation.documentLocation; // NOTE: is a cross-domain iframe

						  if (iframeDocumentLocation === null) return false; // NOTE: after 'document.write' or 'document.open' call for iframe with/without src
						  // we will process it as iframe without src

						  if (native_methods_1.default.contentWindowGetter.call(iframe)[internal_properties_1.default.documentWasCleaned]) return true;
						  var iframeDocumentLocationHaveSupportedProtocol = urlUtils.isSupportedProtocol(iframeDocumentLocation); // NOTE: When an iframe has an empty src attribute (<iframe src></iframe>) or has no src attribute (<iframe></iframe>),
						  // the iframe.src property is not empty but has different values in different browsers.
						  // Its document location is 'about:blank'. Therefore, we should check the src attribute.

						  if (!iframeDocumentLocationHaveSupportedProtocol && !native_methods_1.default.getAttribute.call(iframe, 'src')) return true; // In Chrome, when an iframe with the src attribute is added to DOM,
						  // its documentLocation is set to "about:blank" until the iframe has been loaded.
						  // So, we should check srcLocation in this case.

						  if (iframeSrcLocation && urlUtils.isSupportedProtocol(iframeSrcLocation)) return false;
						  return !iframeDocumentLocationHaveSupportedProtocol;
						}

						exports.isIframeWithoutSrc = isIframeWithoutSrc;

						function isIframeWithSrcdoc(iframe) {
						  return native_methods_1.default.iframeSrcdocGetter && native_methods_1.default.hasAttribute.call(iframe, 'srcdoc');
						}

						exports.isIframeWithSrcdoc = isIframeWithSrcdoc;

						function isImgElement(el) {
						  return instanceToString(el) === '[object HTMLImageElement]';
						}

						exports.isImgElement = isImgElement;

						function isInputElement(el) {
						  return instanceToString(el) === '[object HTMLInputElement]';
						}

						exports.isInputElement = isInputElement;

						function isTitleElement(el) {
						  return instanceToString(el) === '[object HTMLTitleElement]';
						}

						exports.isTitleElement = isTitleElement;

						function isButtonElement(el) {
						  return instanceToString(el) === '[object HTMLButtonElement]';
						}

						exports.isButtonElement = isButtonElement;

						function isFieldSetElement(el) {
						  return instanceToString(el) === '[object HTMLFieldSetElement]';
						}

						exports.isFieldSetElement = isFieldSetElement;

						function isOptGroupElement(el) {
						  return instanceToString(el) === '[object HTMLOptGroupElement]';
						}

						exports.isOptGroupElement = isOptGroupElement;

						function isHtmlElement(el) {
						  return instanceToString(el) === '[object HTMLHtmlElement]';
						}

						exports.isHtmlElement = isHtmlElement;

						function isBodyElement(el) {
						  return instanceToString(el) === '[object HTMLBodyElement]';
						}

						exports.isBodyElement = isBodyElement;

						function isHeadElement(el) {
						  return instanceToString(el) === '[object HTMLHeadElement]';
						}

						exports.isHeadElement = isHeadElement;

						function isHeadOrBodyElement(el) {
						  var elString = instanceToString(el);
						  return elString === '[object HTMLHeadElement]' || elString === '[object HTMLBodyElement]';
						}

						exports.isHeadOrBodyElement = isHeadOrBodyElement;

						function isHeadOrBodyOrHtmlElement(el) {
						  var elString = instanceToString(el);
						  return elString === '[object HTMLHeadElement]' || elString === '[object HTMLBodyElement]' || elString === '[object HTMLHtmlElement]';
						}

						exports.isHeadOrBodyOrHtmlElement = isHeadOrBodyOrHtmlElement;

						function isBaseElement(el) {
						  return instanceToString(el) === '[object HTMLBaseElement]';
						}

						exports.isBaseElement = isBaseElement;

						function isScriptElement(el) {
						  return instanceToString(el) === '[object HTMLScriptElement]';
						}

						exports.isScriptElement = isScriptElement;

						function isStyleElement(el) {
						  return instanceToString(el) === '[object HTMLStyleElement]';
						}

						exports.isStyleElement = isStyleElement;

						function isLabelElement(el) {
						  return instanceToString(el) === '[object HTMLLabelElement]';
						}

						exports.isLabelElement = isLabelElement;

						function isTextAreaElement(el) {
						  return instanceToString(el) === '[object HTMLTextAreaElement]';
						}

						exports.isTextAreaElement = isTextAreaElement;

						function isOptionElement(el) {
						  return instanceToString(el) === '[object HTMLOptionElement]';
						}

						exports.isOptionElement = isOptionElement;

						function isRadioButtonElement(el) {
						  return isInputElement(el) && el.type.toLowerCase() === 'radio';
						}

						exports.isRadioButtonElement = isRadioButtonElement;

						function isColorInputElement(el) {
						  return isInputElement(el) && el.type.toLowerCase() === 'color';
						}

						exports.isColorInputElement = isColorInputElement;

						function isCheckboxElement(el) {
						  return isInputElement(el) && el.type.toLowerCase() === 'checkbox';
						}

						exports.isCheckboxElement = isCheckboxElement;

						function isSelectElement(el) {
						  return instanceToString(el) === '[object HTMLSelectElement]';
						}

						exports.isSelectElement = isSelectElement;

						function isFormElement(el) {
						  return instanceToString(el) === '[object HTMLFormElement]';
						}

						exports.isFormElement = isFormElement;

						function isFileInput(el) {
						  return isInputElement(el) && el.type.toLowerCase() === 'file';
						}

						exports.isFileInput = isFileInput;

						function isInputWithNativeDialog(el) {
						  return isInputElement(el) && INPUT_WITH_NATIVE_DIALOG.test(el.type.toLowerCase());
						}

						exports.isInputWithNativeDialog = isInputWithNativeDialog;

						function isBodyElementWithChildren(el) {
						  return isBodyElement(el) && native_methods_1.default.htmlCollectionLengthGetter.call(el.children);
						}

						exports.isBodyElementWithChildren = isBodyElementWithChildren;

						function isMapElement(el) {
						  return NATIVE_MAP_ELEMENT_STRINGS.indexOf(instanceToString(el)) !== -1;
						}

						exports.isMapElement = isMapElement;

						function isRenderedNode(node) {
						  return !(isProcessingInstructionNode(node) || isCommentNode(node) || SCRIPT_OR_STYLE_RE.test(node.nodeName));
						}

						exports.isRenderedNode = isRenderedNode;

						function getTabIndex(el) {
						  // NOTE: we obtain the tabIndex value from an attribute because the el.tabIndex
						  // property returns -1 for some elements (e.g. for body) with no tabIndex assigned
						  var tabIndex = native_methods_1.default.getAttribute.call(el, 'tabIndex');
						  tabIndex = parseInt(tabIndex, 10);
						  return isNaN(tabIndex) ? null : tabIndex;
						}

						exports.getTabIndex = getTabIndex;

						function isElementFocusable(el) {
						  if (!el) return false;
						  var tabIndex = getTabIndex(el);
						  var isDisabledElement = matches(el, ':disabled');
						  var isInvisibleElement = style_1.get(el, 'visibility') === 'hidden';
						  var isNotDisplayedElement = style_1.get(el, 'display') === 'none';
						  var isHiddenElement = browser_1.isWebKit ? isHidden(el) && !isOptionElement(el) : isHidden(el);
						  if (isDisabledElement || isInvisibleElement || isNotDisplayedElement || isHiddenElement) return false;
						  if (isOptionElement(el) && browser_1.isIE) return false;

						  if (isAnchorElement(el)) {
						    if (tabIndex !== null) return true;
						    return matches(el, 'a[href]');
						  }

						  if (isTableDataCellElement(el) && browser_1.isIE) return true;
						  return matches(el, FOCUSABLE_SELECTOR) || tabIndex !== null;
						}

						exports.isElementFocusable = isElementFocusable;

						function isShadowUIElement(element) {
						  // @ts-ignore
						  return !!element[internal_properties_1.default.shadowUIElement];
						}

						exports.isShadowUIElement = isShadowUIElement;

						function isWindow(instance) {
						  if (instance instanceof native_methods_1.default.windowClass) return true;

						  try {
						    // NOTE: The instanceToString call result has a strange values for the MessageEvent.target property:
						    // * [object DispHTMLWindow2] for IE11
						    // * [object Object] for MSEdge.
						    if ((browser_1.isIE || browser_1.isMSEdge) && instance && instance === instance.window) instance = instance.window;
						    return instance && instance.toString && NATIVE_WINDOW_STR === instanceToString(instance);
						  } catch (e) {
						    try {
						      // NOTE: If a cross-domain object has the 'top' field, this object is a window
						      // (not a document or location).
						      return !!instance.top;
						    } catch (x) {
						      return false;
						    }
						  }
						}

						exports.isWindow = isWindow;

						function isDocument(instance) {
						  if (instance instanceof native_methods_1.default.documentClass) return true;

						  try {
						    return instance && IS_DOCUMENT_RE.test(instanceToString(instance));
						  } catch (e) {
						    // NOTE: For cross-domain objects (windows, documents or locations), we return false because
						    // it's impossible to work with them in any case.
						    return false;
						  }
						}

						exports.isDocument = isDocument;

						function isBlob(instance) {
						  return instance && instanceToString(instance) === '[object Blob]';
						}

						exports.isBlob = isBlob;

						function isLocation(instance) {
						  if (!instance) return false;
						  if (browser_1.isIE || browser_1.isSafari || browser_1.isChrome) return isLocationByProto(instance);
						  return instance instanceof native_methods_1.default.locationClass || native_methods_1.default.objectToString.call(instance) === '[object Location]';
						}

						exports.isLocation = isLocation;

						function isSVGElement(instance) {
						  if (instance instanceof native_methods_1.default.svgElementClass) return true;
						  return instance && IS_SVG_ELEMENT_RE.test(instanceToString(instance));
						}

						exports.isSVGElement = isSVGElement;

						function isSVGElementOrChild(el) {
						  return !!closest(el, 'svg');
						}

						exports.isSVGElementOrChild = isSVGElementOrChild;

						function isFetchHeaders(instance) {
						  if (native_methods_1.default.Headers && instance instanceof native_methods_1.default.Headers) return true;
						  return instance && instanceToString(instance) === '[object Headers]';
						}

						exports.isFetchHeaders = isFetchHeaders;

						function isFetchRequest(instance) {
						  if (native_methods_1.default.Request && instance instanceof native_methods_1.default.Request) return true;
						  return instance && instanceToString(instance) === '[object Request]';
						}

						exports.isFetchRequest = isFetchRequest;

						function isElementReadOnly(el) {
						  return el.readOnly || el.getAttribute('readonly') === 'readonly';
						}

						exports.isElementReadOnly = isElementReadOnly;

						function isTextEditableInput(el) {
						  var attrType = el.getAttribute('type');
						  return isInputElement(el) && attrType ? EDITABLE_INPUT_TYPES_RE.test(attrType) : EDITABLE_INPUT_TYPES_RE.test(el.type);
						}

						exports.isTextEditableInput = isTextEditableInput;

						function isTextEditableElement(el) {
						  return isTextEditableInput(el) || isTextAreaElement(el);
						}

						exports.isTextEditableElement = isTextEditableElement;

						function isTextEditableElementAndEditingAllowed(el) {
						  return isTextEditableElement(el) && !isElementReadOnly(el);
						}

						exports.isTextEditableElementAndEditingAllowed = isTextEditableElementAndEditingAllowed;

						function isElementNode(node) {
						  return node && node.nodeType === ELEMENT_NODE_TYPE;
						}

						exports.isElementNode = isElementNode;

						function isTextNode(node) {
						  return instanceToString(node) === '[object Text]';
						}

						exports.isTextNode = isTextNode;

						function isProcessingInstructionNode(node) {
						  return IS_PROCESSING_INSTRUCTION_RE.test(instanceToString(node));
						}

						exports.isProcessingInstructionNode = isProcessingInstructionNode;

						function isCommentNode(node) {
						  return instanceToString(node) === '[object Comment]';
						}

						exports.isCommentNode = isCommentNode;

						function isDocumentFragmentNode(node) {
						  return instanceToString(node) === '[object DocumentFragment]';
						}

						exports.isDocumentFragmentNode = isDocumentFragmentNode;

						function isShadowRoot(root) {
						  return instanceToString(root) === '[object ShadowRoot]';
						}

						exports.isShadowRoot = isShadowRoot;

						function isAnchorElement(el) {
						  return instanceToString(el) === '[object HTMLAnchorElement]';
						}

						exports.isAnchorElement = isAnchorElement;

						function isTableElement(el) {
						  return instanceToString(el) === '[object HTMLTableElement]';
						}

						exports.isTableElement = isTableElement;

						function isTableDataCellElement(el) {
						  return instanceToString(el) === NATIVE_TABLE_CELL_STR;
						}

						exports.isTableDataCellElement = isTableDataCellElement;

						function isWebSocket(ws) {
						  return instanceToString(ws) === '[object WebSocket]';
						}

						exports.isWebSocket = isWebSocket;

						function isMessageEvent(e) {
						  return instanceToString(e) === '[object MessageEvent]';
						}

						exports.isMessageEvent = isMessageEvent;

						function isPerformanceNavigationTiming(entry) {
						  return instanceToString(entry) === '[object PerformanceNavigationTiming]';
						}

						exports.isPerformanceNavigationTiming = isPerformanceNavigationTiming;

						function isArrayBuffer(data) {
						  if (data instanceof native_methods_1.default.ArrayBuffer) return true;
						  return data && IS_ARRAY_BUFFER_RE.test(instanceToString(data));
						}

						exports.isArrayBuffer = isArrayBuffer;

						function isArrayBufferView(data) {
						  return data && native_methods_1.default.arrayBufferIsView(data);
						}

						exports.isArrayBufferView = isArrayBufferView;

						function isDataView(data) {
						  if (data instanceof native_methods_1.default.DataView) return true;
						  return data && IS_DATA_VIEW_RE.test(instanceToString(data));
						}

						exports.isDataView = isDataView;

						function matches(el, selector) {
						  if (!isElementNode(el)) return false;
						  return native_methods_1.default.matches.call(el, selector);
						}

						exports.matches = matches;

						function closest(el, selector) {
						  if (!isElementNode(el)) return null;
						  if (native_methods_1.default.closest) return native_methods_1.default.closest.call(el, selector);
						  return closestFallback(el, selector);
						}

						exports.closest = closest;

						function addClass(el, className) {
						  if (!el) return;
						  var classNames = className.split(/\s+/);

						  for (var _i2 = 0; _i2 < classNames.length; _i2++) {
						    var currentClassName = classNames[_i2];
						    native_methods_1.default.tokenListAdd.call(native_methods_1.default.elementClassListGetter.call(el), currentClassName);
						  }
						}

						exports.addClass = addClass;

						function removeClass(el, className) {
						  if (!el) return;
						  var classNames = className.split(/\s+/);

						  for (var _i4 = 0; _i4 < classNames.length; _i4++) {
						    var currentClassName = classNames[_i4];
						    native_methods_1.default.tokenListRemove.call(native_methods_1.default.elementClassListGetter.call(el), currentClassName);
						  }
						}

						exports.removeClass = removeClass;

						function hasClass(el, className) {
						  if (!el) return false;
						  return native_methods_1.default.tokenListContains.call(native_methods_1.default.elementClassListGetter.call(el), className);
						}

						exports.hasClass = hasClass;

						function parseDocumentCharset() {
						  var metaCharset = native_methods_1.default.querySelector.call(document, '.' + class_name_1.default.charset);
						  return metaCharset && metaCharset.getAttribute('charset');
						}

						exports.parseDocumentCharset = parseDocumentCharset;

						function getParents(el, selector) {
						  var parents = [];
						  var parent = getParent(el);

						  while (parent) {
						    if (!selector && isElementNode(parent) || selector && matches(parent, selector)) parents.push(parent);
						    parent = getParent(parent);
						  }

						  return parents;
						}

						exports.getParents = getParents;

						function getParent(el) {
						  el = el.assignedSlot || el; // eslint-disable-next-line no-restricted-properties

						  return native_methods_1.default.nodeParentNodeGetter.call(el) || el.host;
						}

						function findParent(node, includeSelf, predicate) {
						  if (includeSelf === void 0) {
						    includeSelf = false;
						  }

						  if (!includeSelf) node = native_methods_1.default.nodeParentNodeGetter.call(node);

						  while (node) {
						    if (typeof predicate !== 'function' || predicate(node)) return node;
						    node = native_methods_1.default.nodeParentNodeGetter.call(node);
						  }

						  return null;
						}

						exports.findParent = findParent;

						function nodeListToArray(nodeList) {
						  var result = [];
						  var length = native_methods_1.default.nodeListLengthGetter.call(nodeList);

						  for (var i = 0; i < length; i++) {
						    result.push(nodeList[i]);
						  }

						  return result;
						}

						exports.nodeListToArray = nodeListToArray;

						function getFileInputs(el) {
						  return isFileInput(el) ? [el] : nodeListToArray(query_selector_1.getNativeQuerySelectorAll(el).call(el, 'input[type=file]'));
						}

						exports.getFileInputs = getFileInputs;

						function getIframes(el) {
						  return isIframeElement(el) ? [el] : nodeListToArray(query_selector_1.getNativeQuerySelectorAll(el).call(el, 'iframe,frame'));
						}

						exports.getIframes = getIframes;

						function getScripts(el) {
						  return isScriptElement(el) ? [el] : nodeListToArray(query_selector_1.getNativeQuerySelectorAll(el).call(el, 'script'));
						}

						exports.getScripts = getScripts;

						function isNumberOrEmailInput(el) {
						  return isInputElement(el) && NUMBER_OR_EMAIL_INPUT_RE.test(el.type);
						}

						exports.isNumberOrEmailInput = isNumberOrEmailInput;

						function isInputWithoutSelectionProperties(el) {
						  if (!isNumberOrEmailInput(el)) return false;
						  var hasSelectionProperties = typeof el.selectionStart === 'number' && typeof el.selectionEnd === 'number';
						  return !hasSelectionProperties;
						}

						exports.isInputWithoutSelectionProperties = isInputWithoutSelectionProperties;
					},
					"event-emitter.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var browser_1 = require("./browser");

						var EventEmitter = /*#__PURE__*/function () {
						  function EventEmitter() {
						    this.eventsListeners = native_methods_1.default.objectCreate(null);
						  }

						  var _proto = EventEmitter.prototype;

						  _proto.emit = function emit(evt) {
						    var listeners = this.eventsListeners[evt];
						    if (!listeners) return;
						    var index = 0;

						    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						      args[_key - 1] = arguments[_key];
						    }

						    while (listeners[index]) {
						      // HACK: For IE: after calling document.write, the IFrameSandbox event handler throws the
						      // 'Can't execute code from a freed script' exception because the document has been
						      // recreated.
						      if (browser_1.isIE) {
						        try {
						          listeners[index].toString();
						        } catch (e) {
						          native_methods_1.default.arraySplice.call(listeners, index, 1);
						          continue;
						        }
						      }

						      listeners[index++].apply(this, args);
						    }
						  };

						  _proto.off = function off(evt, listener) {
						    var listeners = this.eventsListeners[evt];
						    if (!listeners) return;
						    this.eventsListeners[evt] = native_methods_1.default.arrayFilter.call(listeners, function (currentListener) {
						      return currentListener !== listener;
						    });
						  };

						  _proto.on = function on(evt, listener) {
						    this.eventsListeners[evt] = this.eventsListeners[evt] || [];
						    if (this.eventsListeners[evt].indexOf(listener) === -1) this.eventsListeners[evt].push(listener);
						    return listener;
						  };

						  return EventEmitter;
						}();

						exports.default = EventEmitter;
						module.exports = exports.default;
					},
					"event.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var COMPOSED_EVENTS = ['blur', 'focus', 'focusin', 'focusout', 'click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'beforeinput', 'input', 'keydown', 'keyup'];
						exports.BUTTON = {
						  left: 0,
						  middle: 1,
						  right: 2
						};
						exports.BUTTONS_PARAMETER = {
						  noButton: 0,
						  leftButton: 1,
						  rightButton: 2
						};
						exports.WHICH_PARAMETER = {
						  noButton: 0,
						  leftButton: 1,
						  middleButton: 2,
						  rightButton: 3
						};
						exports.KEYBOARD_MODIFIERS_PARAMETER = {
						  altKey: 'Alt',
						  ctrlKey: 'Control',
						  shiftKey: 'Shift',
						  metaKey: 'Meta'
						};
						exports.DOM_EVENTS = ['click', 'dblclick', 'contextmenu', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchend', 'keydown', 'keypress', 'keyup', 'textInput', 'textinput', 'input', 'change', 'focus', 'blur', 'MSPointerDown', 'MSPointerMove', 'MSPointerOver', 'MSPointerOut', 'MSPointerUp', 'pointerdown', 'pointermove', 'pointerover', 'pointerout', 'pointerup', 'pointerenter', 'pointerleave', 'dragstart', 'drop', 'focusin', 'focusout'];

						function preventDefault(ev, allowBubbling) {
						  if (ev.preventDefault) ev.preventDefault();else ev.returnValue = false;
						  if (!allowBubbling) stopPropagation(ev);
						}

						exports.preventDefault = preventDefault;

						function stopPropagation(ev) {
						  if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();else if (ev.stopPropagation) ev.stopPropagation();
						  ev.cancelBubble = true;
						}

						exports.stopPropagation = stopPropagation;

						function isObjectEventListener(listener) {
						  return typeof listener === 'object' && listener && typeof listener.handleEvent === 'function';
						}

						exports.isObjectEventListener = isObjectEventListener;

						function isValidEventListener(listener) {
						  return typeof listener === 'function' || isObjectEventListener(listener);
						}

						exports.isValidEventListener = isValidEventListener;

						function callEventListener(ctx, listener, e) {
						  if (isObjectEventListener(listener)) return listener.handleEvent.call(listener, e);
						  return listener.call(ctx, e);
						}

						exports.callEventListener = callEventListener;

						function isComposedEvent(event) {
						  return COMPOSED_EVENTS.indexOf(event) !== -1;
						}

						exports.isComposedEvent = isComposedEvent;
						exports.hasPointerEvents = !!(native_methods_1.default.WindowPointerEvent || native_methods_1.default.WindowMSPointerEvent);
					},
					"feature-detection.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						var __importStar = void 0 && (void 0).__importStar || function (mod) {
						  if (mod && mod.__esModule) return mod;
						  var result = {};
						  if (mod != null) for (var k in mod) {
						    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
						  }
						  result["default"] = mod;
						  return result;
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var browserUtils = __importStar(require("./browser"));

						exports.emptyActionAttrFallbacksToTheLocation = false;
						exports.instanceAndPrototypeToStringAreEqual = false;
						exports.hasTouchEvents = false;
						exports.hasTouchPoints = false;
						exports.isTouchDevice = false;
						exports.hasDataTransfer = false;
						exports.attrGetNamedItemIsNotEnumerable = false;
						exports.getElementsByNameReturnsHTMLCollection = false;

						if (native_methods_1.default.createElement) {
						  var form = native_methods_1.default.createElement.call(document, 'form');
						  var elements = native_methods_1.default.getElementsByName.call(document, ''); // NOTE: In some browsers, elements without the url attribute return the location url
						  // when accessing this attribute directly. See form.action in Edge 25 as an example.

						  exports.emptyActionAttrFallbacksToTheLocation = native_methods_1.default.formActionGetter.call(form) === window.location.toString(); // NOTE: In Chrome, toString(window) equals '[object Window]' and toString(Window.prototype) equals '[object Blob]',
						  // this condition is also satisfied for Blob, Document, XMLHttpRequest, etc

						  exports.instanceAndPrototypeToStringAreEqual = native_methods_1.default.objectToString.call(window) === native_methods_1.default.objectToString.call(Window.prototype);
						  exports.hasTouchEvents = 'ontouchstart' in window; // NOTE: We need to check touch points only for IE, because it has PointerEvent and MSPointerEvent (IE10, IE11)
						  // instead of TouchEvent (T109295).

						  exports.hasTouchPoints = browserUtils.isIE && (navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0);
						  exports.isTouchDevice = (browserUtils.isMobile || browserUtils.isTablet) && exports.hasTouchEvents; // @ts-ignore

						  exports.hasDataTransfer = !!window.DataTransfer; // NOTE: In the Edge 17, the getNamedItem method of attributes object is not enumerable

						  exports.attrGetNamedItemIsNotEnumerable = !!native_methods_1.default.objectGetOwnPropertyDescriptor.call(window.Object, NamedNodeMap.prototype, 'getNamedItem'); // Both IE and Edge return an HTMLCollection, not a NodeList
						  // @ts-ignore

						  exports.getElementsByNameReturnsHTMLCollection = native_methods_1.default.objectGetPrototypeOf.call(window.Object, elements) === native_methods_1.default.HTMLCollection.prototype;
						}
					},
					"global-context-info.js": function (exports, module, require) {
						

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});
						var isInWorker = typeof window === 'undefined' && typeof self === 'object';
						var global = isInWorker ? self : window;
						exports.default = {
						  isInWorker: isInWorker,
						  global: global,
						  isServiceWorker: isInWorker && !global.XMLHttpRequest
						};
						module.exports = exports.default;
					},
					"noop.js": function (exports, module, require) {
						

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						function default_1() {// NOTE: empty function
						}

						exports.default = default_1;
						module.exports = exports.default;
					},
					"overriding.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var internal_properties_1 = __importDefault(require("../../processing/dom/internal-properties"));

						function replaceNativeAccessor(descriptor, accessorName, newAccessor) {
						  if (newAccessor && descriptor[accessorName]) {
						    var stringifiedNativeAccessor = descriptor[accessorName].toString();

						    newAccessor.toString = function () {
						      return stringifiedNativeAccessor;
						    };
						  }

						  descriptor[accessorName] = newAccessor;
						}

						function createOverriddenDescriptor(obj, prop, _ref) {
						  var getter = _ref.getter,
						      setter = _ref.setter,
						      value = _ref.value;
						  var descriptor = native_methods_1.default.objectGetOwnPropertyDescriptor(obj, prop);
						  if ((getter || setter) && value) throw new Error('Cannot both specify accessors and a value or writable attribute.');

						  if (value) {
						    if (!native_methods_1.default.objectHasOwnProperty.call(descriptor, 'writable')) {
						      descriptor.writable = !!descriptor.set;
						      delete descriptor.get;
						      delete descriptor.set;
						    }

						    descriptor.value = value; // eslint-disable-line no-restricted-properties
						  } else {
						    if (native_methods_1.default.objectHasOwnProperty.call(descriptor, 'writable')) {
						      delete descriptor.value; // eslint-disable-line no-restricted-properties

						      delete descriptor.writable;
						    }

						    if (getter !== null) replaceNativeAccessor(descriptor, 'get', getter);
						    if (setter !== null) replaceNativeAccessor(descriptor, 'set', setter);
						  }

						  return descriptor;
						}

						exports.createOverriddenDescriptor = createOverriddenDescriptor;

						function overrideDescriptor(obj, prop, propertyAccessors) {
						  var descriptor = createOverriddenDescriptor(obj, prop, propertyAccessors);
						  native_methods_1.default.objectDefineProperty(obj, prop, descriptor);
						}

						exports.overrideDescriptor = overrideDescriptor;

						function overrideFunctionName(fn, name) {
						  var nameDescriptor = native_methods_1.default.objectGetOwnPropertyDescriptor(fn, 'name');
						  if (!nameDescriptor) return;
						  nameDescriptor.value = name; // eslint-disable-line no-restricted-properties

						  native_methods_1.default.objectDefineProperty(fn, 'name', nameDescriptor);
						}

						function overrideToString(nativeFnWrapper, nativeFn) {
						  native_methods_1.default.objectDefineProperty(nativeFnWrapper, internal_properties_1.default.nativeStrRepresentation, {
						    value: native_methods_1.default.Function.prototype.toString.call(nativeFn),
						    configurable: true
						  });
						} // TODO: this function should not be used outside this file
						// for now it's used to flag cases in which we assign our wrapper to a native function when it is missing


						function overrideStringRepresentation(nativeFnWrapper, nativeFn) {
						  overrideFunctionName(nativeFnWrapper, nativeFn.name);
						  overrideToString(nativeFnWrapper, nativeFn);
						}

						exports.overrideStringRepresentation = overrideStringRepresentation;

						function isNativeFunction(fn) {
						  return !native_methods_1.default.objectHasOwnProperty.call(fn, internal_properties_1.default.nativeStrRepresentation);
						}

						exports.isNativeFunction = isNativeFunction;

						function overrideFunction(obj, fnName, wrapper) {
						  var fn = obj[fnName];

						  if (isNativeFunction(fn)) {
						    overrideStringRepresentation(wrapper, fn);
						    obj[fnName] = wrapper;
						  }
						}

						exports.overrideFunction = overrideFunction;

						function overrideConstructor(obj, fnName, wrapper, overrideProtoConstructor) {
						  if (overrideProtoConstructor === void 0) {
						    overrideProtoConstructor = false;
						  }

						  var nativePrototype = obj[fnName]['prototype'];
						  overrideFunction(obj, fnName, wrapper); // NOTE: restore native prototype (to make `instanceof` work as expected)

						  obj[fnName]['prototype'] = nativePrototype; // NOTE: we need to override the `constructor` property of a prototype
						  // because sometimes native constructor can be retrieved from it

						  if (overrideProtoConstructor) obj[fnName]['prototype']['constructor'] = wrapper;
						}

						exports.overrideConstructor = overrideConstructor;
					},
					"query-selector.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var dom_1 = require("./dom");

						function getNativeQuerySelector(el) {
						  if (dom_1.isDomElement(el)) return native_methods_1.default.elementQuerySelector;
						  return dom_1.isDocumentFragmentNode(el) || dom_1.isShadowRoot(el) ? native_methods_1.default.documentFragmentQuerySelector : native_methods_1.default.querySelector;
						}

						exports.getNativeQuerySelector = getNativeQuerySelector;

						function getNativeQuerySelectorAll(el) {
						  // NOTE: Do not return the isDocument function instead of the isDomElement
						  // it leads to the `Invalid calling object` error in some cases in IE11 (GH-1846)
						  if (dom_1.isDomElement(el)) return native_methods_1.default.elementQuerySelectorAll;
						  return dom_1.isDocumentFragmentNode(el) || dom_1.isShadowRoot(el) ? native_methods_1.default.documentFragmentQuerySelectorAll : native_methods_1.default.querySelectorAll;
						}

						exports.getNativeQuerySelectorAll = getNativeQuerySelectorAll;
					},
					"style.js": function (exports, module, require) {
						

						var __importStar = void 0 && (void 0).__importStar || function (mod) {
						  if (mod && mod.__esModule) return mod;
						  var result = {};
						  if (mod != null) for (var k in mod) {
						    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
						  }
						  result["default"] = mod;
						  return result;
						};

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var domUtils = __importStar(require("./dom"));

						var browserUtils = __importStar(require("./browser"));

						var featureDetection = __importStar(require("./feature-detection"));

						var native_methods_1 = __importDefault(require("../sandbox/native-methods")); // NOTE: For Chrome.


						var MIN_SELECT_SIZE_VALUE = 4;

						function getIntValue(value) {
						  value = value || '';
						  var parsedValue = parseInt(value.replace('px', ''), 10);
						  return isNaN(parsedValue) ? 0 : parsedValue;
						}

						function get(el, property, doc, win) {
						  el = el.documentElement || el;
						  var computedStyle = getComputedStyle(el, doc, win);
						  return computedStyle && computedStyle[property];
						}

						exports.get = get;

						function set(el, property, value) {
						  el = el.documentElement || el;
						  el.style[property] = value;
						}

						exports.set = set;

						function getBordersWidth(el) {
						  return {
						    bottom: getIntValue(get(el, 'borderBottomWidth')),
						    left: getIntValue(get(el, 'borderLeftWidth')),
						    right: getIntValue(get(el, 'borderRightWidth')),
						    top: getIntValue(get(el, 'borderTopWidth'))
						  };
						}

						exports.getBordersWidth = getBordersWidth;

						function getComputedStyle(el, doc, win) {
						  // NOTE: In Firefox, after calling the 'document.write' function for nested iframes with html src value
						  // document.defaultView equals 'null'. But 'window.document' equals 'document'.
						  // This is why, we are forced to calculate the targetWindow instead of use document.defaultView.
						  doc = doc || document;
						  win = win || window;
						  var targetWin = doc.defaultView || win;
						  return targetWin.getComputedStyle(el, null);
						}

						exports.getComputedStyle = getComputedStyle;

						function getElementMargin(el) {
						  return {
						    bottom: getIntValue(get(el, 'marginBottom')),
						    left: getIntValue(get(el, 'marginLeft')),
						    right: getIntValue(get(el, 'marginRight')),
						    top: getIntValue(get(el, 'marginTop'))
						  };
						}

						exports.getElementMargin = getElementMargin;

						function getElementPadding(el) {
						  return {
						    bottom: getIntValue(get(el, 'paddingBottom')),
						    left: getIntValue(get(el, 'paddingLeft')),
						    right: getIntValue(get(el, 'paddingRight')),
						    top: getIntValue(get(el, 'paddingTop'))
						  };
						}

						exports.getElementPadding = getElementPadding;

						function getElementScroll(el) {
						  var isHtmlElement = domUtils.isHtmlElement(el);
						  var currentWindow = window;

						  if (isHtmlElement && domUtils.isElementInIframe(el)) {
						    var currentIframe = domUtils.getIframeByElement(el);
						    if (currentIframe) currentWindow = native_methods_1.default.contentWindowGetter.call(currentIframe);
						  }

						  var targetEl = isHtmlElement ? currentWindow : el;
						  return {
						    left: getScrollLeft(targetEl),
						    top: getScrollTop(targetEl)
						  };
						}

						exports.getElementScroll = getElementScroll;

						function getWidth(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.document.documentElement.clientWidth;

						  if (domUtils.isDocument(el)) {
						    var doc = el.documentElement;
						    var clientProp = 'clientWidth';
						    var scrollProp = 'scrollWidth';
						    var offsetProp = 'offsetWidth';
						    if (doc[clientProp] >= doc[scrollProp]) return doc[clientProp];
						    return Math.max(el.body[scrollProp], doc[scrollProp], el.body[offsetProp], doc[offsetProp]);
						  }

						  var value = el.offsetWidth;
						  value -= getIntValue(get(el, 'paddingLeft'));
						  value -= getIntValue(get(el, 'paddingRight'));
						  value -= getIntValue(get(el, 'borderLeftWidth'));
						  value -= getIntValue(get(el, 'borderRightWidth'));
						  return value;
						}

						exports.getWidth = getWidth;

						function getHeight(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.document.documentElement.clientHeight;

						  if (domUtils.isDocument(el)) {
						    var doc = el.documentElement;
						    var clientProp = 'clientHeight';
						    var scrollProp = 'scrollHeight';
						    var offsetProp = 'offsetHeight';
						    if (doc[clientProp] >= doc[scrollProp]) return doc[clientProp];
						    return Math.max(el.body[scrollProp], doc[scrollProp], el.body[offsetProp], doc[offsetProp]);
						  }

						  var value = el.offsetHeight;
						  value -= getIntValue(get(el, 'paddingTop'));
						  value -= getIntValue(get(el, 'paddingBottom'));
						  value -= getIntValue(get(el, 'borderTopWidth'));
						  value -= getIntValue(get(el, 'borderBottomWidth'));
						  return value;
						}

						exports.getHeight = getHeight;

						function getInnerWidth(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.document.documentElement.clientWidth;
						  if (domUtils.isDocument(el)) return el.documentElement.clientWidth;
						  var value = el.offsetWidth;
						  value -= getIntValue(get(el, 'borderLeftWidth'));
						  value -= getIntValue(get(el, 'borderRightWidth'));
						  return value;
						}

						exports.getInnerWidth = getInnerWidth;

						function getInnerHeight(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.document.documentElement.clientHeight;
						  if (domUtils.isDocument(el)) return el.documentElement.clientHeight;
						  var value = el.offsetHeight;
						  value -= getIntValue(get(el, 'borderTopWidth'));
						  value -= getIntValue(get(el, 'borderBottomWidth'));
						  return value;
						}

						exports.getInnerHeight = getInnerHeight;

						function getOptionHeight(select) {
						  var realSizeValue = getSelectElementSize(select);
						  var selectPadding = getElementPadding(select);
						  var selectScrollHeight = select.scrollHeight - (selectPadding.top + selectPadding.bottom);
						  var childrenCount = domUtils.getSelectVisibleChildren(select).length;
						  if (realSizeValue === 1) return getHeight(select);
						  return browserUtils.isIE && realSizeValue > childrenCount ? Math.round(selectScrollHeight / childrenCount) : Math.round(selectScrollHeight / Math.max(childrenCount, realSizeValue));
						}

						exports.getOptionHeight = getOptionHeight;

						function getSelectElementSize(select) {
						  // NOTE: iOS and Android ignore 'size' and 'multiple' attributes,
						  // all select elements behave like a select with size=1.
						  if (browserUtils.isSafari && featureDetection.hasTouchEvents || browserUtils.isAndroid) return 1;
						  var sizeAttr = native_methods_1.default.getAttribute.call(select, 'size');
						  var multipleAttr = native_methods_1.default.getAttribute.call(select, 'multiple');
						  var size = !sizeAttr ? 1 : parseInt(sizeAttr, 10);
						  if (multipleAttr && (!sizeAttr || size < 1)) size = MIN_SELECT_SIZE_VALUE;
						  return size;
						}

						exports.getSelectElementSize = getSelectElementSize;

						function isVisibleChild(el) {
						  var select = domUtils.getSelectParent(el);
						  var tagName = domUtils.getTagName(el);
						  return domUtils.isSelectElement(select) && getSelectElementSize(select) > 1 && (tagName === 'option' || tagName === 'optgroup') && ( // NOTE: Firefox does not display groups without a label or with an empty label.
						  !browserUtils.isFirefox || el.label);
						}

						exports.isVisibleChild = isVisibleChild;

						function getScrollLeft(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.pageXOffset;
						  if (domUtils.isDocument(el)) return el.defaultView.pageXOffset;
						  return el.scrollLeft;
						}

						exports.getScrollLeft = getScrollLeft;

						function getScrollTop(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.pageYOffset;
						  if (domUtils.isDocument(el)) return el.defaultView.pageYOffset;
						  return el.scrollTop;
						}

						exports.getScrollTop = getScrollTop;

						function setScrollLeft(el, value) {
						  if (!el) return;

						  if (domUtils.isWindow(el) || domUtils.isDocument(el)) {
						    var win = domUtils.findDocument(el).defaultView;
						    var scrollTop = getScrollTop(el);
						    native_methods_1.default.scrollTo.call(win, value, scrollTop);
						  } else el.scrollLeft = value;
						}

						exports.setScrollLeft = setScrollLeft;

						function setScrollTop(el, value) {
						  if (!el) return;

						  if (domUtils.isWindow(el) || domUtils.isDocument(el)) {
						    var win = domUtils.findDocument(el).defaultView;
						    var scrollLeft = getScrollLeft(el);
						    native_methods_1.default.scrollTo.call(win, scrollLeft, value);
						  } else el.scrollTop = value;
						}

						exports.setScrollTop = setScrollTop;

						function getOffsetParent(el) {
						  if (el) {
						    var offsetParent = el.offsetParent || document.body;

						    while (offsetParent && !/^(?:body|html)$/i.test(offsetParent.nodeName) && get(offsetParent, 'position') === 'static') {
						      offsetParent = offsetParent.offsetParent;
						    }

						    return offsetParent;
						  }

						  return void 0;
						}

						exports.getOffsetParent = getOffsetParent;

						function getOffset(el) {
						  if (!el || domUtils.isWindow(el) || domUtils.isDocument(el)) return null;
						  var clientRect = el.getBoundingClientRect(); // NOTE: A detached node or documentElement.

						  var doc = el.ownerDocument;
						  var docElement = doc.documentElement;

						  if (!docElement.contains(el) || el === docElement) {
						    return {
						      top: clientRect.top,
						      left: clientRect.left
						    };
						  }

						  var win = doc.defaultView;
						  var clientTop = docElement.clientTop || doc.body.clientTop || 0;
						  var clientLeft = docElement.clientLeft || doc.body.clientLeft || 0;
						  var scrollTop = win.pageYOffset || docElement.scrollTop || doc.body.scrollTop;
						  var scrollLeft = win.pageXOffset || docElement.scrollLeft || doc.body.scrollLeft;
						  clientRect = el.getBoundingClientRect();
						  return {
						    top: clientRect.top + scrollTop - clientTop,
						    left: clientRect.left + scrollLeft - clientLeft
						  };
						}

						exports.getOffset = getOffset;

						function isElementVisible(el, doc) {
						  if (!domUtils.isElementInDocument(el, doc)) return false;

						  while (el) {
						    if (get(el, 'display', doc) === 'none' || get(el, 'visibility', doc) === 'hidden') return false;
						    el = domUtils.getParentExceptShadowRoot(el);
						  }

						  return true;
						}

						exports.isElementVisible = isElementVisible;

						function isElementInInvisibleIframe(el) {
						  var frameElement = domUtils.getIframeByElement(el);
						  return frameElement && !isElementVisible(frameElement, domUtils.findDocument(frameElement));
						}

						exports.isElementInInvisibleIframe = isElementInInvisibleIframe;
					},
					"url-resolver.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						var __importStar = void 0 && (void 0).__importStar || function (mod) {
						  if (mod && mod.__esModule) return mod;
						  var result = {};
						  if (mod != null) for (var k in mod) {
						    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
						  }
						  result["default"] = mod;
						  return result;
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var destLocation = __importStar(require("../utils/destination-location"));

						var url_1 = require("../../utils/url");

						var dom_1 = require("./dom");

						var DOCUMENT_URL_RESOLVER = 'hammerhead|document-url-resolver';
						exports.default = {
						  _createResolver: function _createResolver(doc) {
						    var htmlDocument = native_methods_1.default.createHTMLDocument.call(doc.implementation, 'title');
						    var a = native_methods_1.default.createElement.call(htmlDocument, 'a');
						    var base = native_methods_1.default.createElement.call(htmlDocument, 'base');
						    native_methods_1.default.appendChild.call(htmlDocument.body, a);
						    native_methods_1.default.appendChild.call(htmlDocument.head, base);
						    return htmlDocument;
						  },
						  _getResolver: function _getResolver(doc) {
						    // NOTE: Once a document is recreated (document.open, document.write is called), nativeMethods will be refreshed.
						    // If we call urlResolve.updateBase after this,
						    // we will use native methods from an actual document.
						    // However, a document that contains an element for url resolving is created using a previous version of nativeMethods.
						    if (!doc[DOCUMENT_URL_RESOLVER]) {
						      native_methods_1.default.objectDefineProperty(doc, DOCUMENT_URL_RESOLVER, {
						        value: this._createResolver(doc),
						        writable: true
						      });
						    }

						    return doc[DOCUMENT_URL_RESOLVER];
						  },
						  _isNestedIframeWithoutSrc: function _isNestedIframeWithoutSrc(win) {
						    if (!win || !win.parent || win.parent === win || win.parent.parent === win.parent) return false;
						    var iframeElement = dom_1.getFrameElement(window);
						    return !!iframeElement && dom_1.isIframeWithoutSrc(iframeElement);
						  },
						  init: function init(doc) {
						    this.updateBase(destLocation.get(), doc);
						  },
						  getResolverElement: function getResolverElement(doc) {
						    return native_methods_1.default.nodeFirstChildGetter.call(this._getResolver(doc).body);
						  },
						  resolve: function resolve(url, doc) {
						    var resolver = this.getResolverElement(doc);
						    var href = null;
						    if (url === null) native_methods_1.default.removeAttribute.call(resolver, 'href');else {
						      native_methods_1.default.anchorHrefSetter.call(resolver, url);
						      href = native_methods_1.default.anchorHrefGetter.call(resolver); // NOTE: It looks like a Chrome bug: in a nested iframe without src (when an iframe is placed into another
						      // iframe) you cannot set a relative link href while the iframe loading is not completed. So, we'll do it with
						      // the parent's urlResolver Safari demonstrates similar behavior, but urlResolver.href has a relative URL value.

						      var needUseParentResolver = url && (!href || href.charAt(0) === '/') && this._isNestedIframeWithoutSrc(doc.defaultView);

						      if (needUseParentResolver) return this.resolve(url, window.parent.document);
						    }
						    return url_1.ensureTrailingSlash(url, href);
						  },
						  updateBase: function updateBase(url, doc) {
						    var resolverDocument = this._getResolver(doc);

						    var baseElement = native_methods_1.default.elementGetElementsByTagName.call(resolverDocument.head, 'base')[0];
						    url = url || destLocation.get();
						    /*eslint-disable no-restricted-properties*/

						    var parsedUrl = url_1.parseUrl(url);
						    var isRelativeUrl = parsedUrl.protocol !== 'file:' && !parsedUrl.host;
						    var isProtocolRelativeUrl = /^\/\//.test(url) && !!parsedUrl.host;
						    /*eslint-enable no-restricted-properties*/

						    if (isRelativeUrl || isProtocolRelativeUrl) {
						      var destinationLocation = destLocation.get();
						      this.updateBase(destinationLocation, doc);
						      url = this.resolve(url, doc);
						    }

						    native_methods_1.default.setAttribute.call(baseElement, 'href', url);
						  },
						  getBaseUrl: function getBaseUrl(doc) {
						    var baseElement = native_methods_1.default.elementGetElementsByTagName.call(this._getResolver(doc).head, 'base')[0];
						    return native_methods_1.default.getAttribute.call(baseElement, 'href');
						  },
						  changeUrlPart: function changeUrlPart(url, nativePropSetter, value, doc) {
						    var resolver = this.getResolverElement(doc);
						    native_methods_1.default.anchorHrefSetter.call(resolver, url);
						    nativePropSetter.call(resolver, value);
						    return native_methods_1.default.anchorHrefGetter.call(resolver);
						  },
						  dispose: function dispose(doc) {
						    doc[DOCUMENT_URL_RESOLVER] = null;
						  }
						};
						module.exports = exports.default;
					},
					"url.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						var __importStar = void 0 && (void 0).__importStar || function (mod) {
						  if (mod && mod.__esModule) return mod;
						  var result = {};
						  if (mod != null) for (var k in mod) {
						    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
						  }
						  result["default"] = mod;
						  return result;
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var internal_properties_1 = __importDefault(require("../../processing/dom/internal-properties"));

						var sharedUrlUtils = __importStar(require("../../utils/url"));

						var destLocation = __importStar(require("./destination-location"));

						var urlResolver = __importStar(require("./url-resolver"));

						var settings_1 = __importDefault(require("../settings"));

						var global_context_info_1 = __importDefault(require("./global-context-info"));

						var destination_location_1 = require("./destination-location");

						var HASH_RE = /#[\S\s]*$/;
						var SUPPORTED_WEB_SOCKET_PROTOCOL_RE = /^wss?:/i;
						var SCOPE_RE = /\/[^/]*$/; // NOTE: The window.location equals 'about:blank' in iframes without src
						// therefore we need to find a window with src to get the proxy settings

						exports.DEFAULT_PROXY_SETTINGS = function () {
						  /*eslint-disable no-restricted-properties*/
						  var locationWindow = global_context_info_1.default.isInWorker ? {
						    location: parseUrl(self.location.origin),
						    parent: null
						  } : window;
						  var proxyLocation = locationWindow.location;

						  while (!proxyLocation.hostname) {
						    locationWindow = locationWindow.parent;
						    proxyLocation = locationWindow.location;
						  }

						  return {
						    hostname: proxyLocation.hostname,
						    port: proxyLocation.port.toString(),
						    protocol: proxyLocation.protocol
						  };
						  /*eslint-enable no-restricted-properties*/
						}();

						exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = sharedUrlUtils.REQUEST_DESCRIPTOR_VALUES_SEPARATOR;

						function getProxyUrl(url, opts) {
						  url = sharedUrlUtils.getURLString(url);
						  var resourceType = opts && opts.resourceType;
						  var parsedResourceType = sharedUrlUtils.parseResourceType(resourceType);
						  if (!parsedResourceType.isWebSocket && !isSupportedProtocol(url) && !isSpecialPage(url)) return url; // NOTE: Resolves relative URLs.

						  var resolvedUrl = destLocation.resolveUrl(url, opts && opts.doc);
						  if (parsedResourceType.isWebSocket && !isValidWebSocketUrl(resolvedUrl) || !sharedUrlUtils.isValidUrl(resolvedUrl)) return url;
						  /*eslint-disable no-restricted-properties*/

						  var proxyHostname = opts && opts.proxyHostname || exports.DEFAULT_PROXY_SETTINGS.hostname;
						  var proxyPort = opts && opts.proxyPort || exports.DEFAULT_PROXY_SETTINGS.port;
						  var proxyServerProtocol = opts && opts.proxyProtocol || exports.DEFAULT_PROXY_SETTINGS.protocol;
						  /*eslint-enable no-restricted-properties*/

						  var proxyProtocol = parsedResourceType.isWebSocket ? proxyServerProtocol.replace('http', 'ws') : proxyServerProtocol;
						  var sessionId = opts && opts.sessionId || settings_1.default.get().sessionId;
						  var windowId = opts && opts.windowId || settings_1.default.get().windowId;
						  var credentials = opts && opts.credentials;
						  var charset = opts && opts.charset;
						  var reqOrigin = opts && opts.reqOrigin;
						  var crossDomainPort = getCrossDomainProxyPort(proxyPort); // NOTE: If the relative URL contains no slash (e.g. 'img123'), the resolver will keep
						  // the original proxy information, so that we can return such URL as is.
						  // TODO: Implement the isProxyURL function.

						  var parsedProxyUrl = sharedUrlUtils.parseProxyUrl(resolvedUrl);
						  /*eslint-disable no-restricted-properties*/

						  var isValidProxyUrl = !!parsedProxyUrl && parsedProxyUrl.proxy.hostname === proxyHostname && (parsedProxyUrl.proxy.port === proxyPort || parsedProxyUrl.proxy.port === crossDomainPort);
						  /*eslint-enable no-restricted-properties*/

						  if (isValidProxyUrl) {
						    if (resourceType && parsedProxyUrl.resourceType === resourceType) return resolvedUrl; // NOTE: Need to change the proxy URL resource type.

						    var destUrl = sharedUrlUtils.formatUrl(parsedProxyUrl.destResourceInfo);
						    return getProxyUrl(destUrl, {
						      proxyProtocol: proxyProtocol,
						      proxyHostname: proxyHostname,
						      proxyPort: proxyPort,
						      sessionId: sessionId,
						      resourceType: resourceType,
						      charset: charset,
						      reqOrigin: reqOrigin,
						      credentials: credentials
						    });
						  }

						  var parsedUrl = sharedUrlUtils.parseUrl(resolvedUrl);
						  if (!parsedUrl.protocol) // eslint-disable-line no-restricted-properties
						    return url;
						  charset = charset || (parsedResourceType.isScript || parsedResourceType.isServiceWorker) && document[internal_properties_1.default.documentCharset]; // NOTE: It seems that the relative URL had the leading slash or dots, so that the proxy info path part was
						  // removed by the resolver and we have an origin URL with the incorrect host and protocol.

						  /*eslint-disable no-restricted-properties*/

						  if (parsedUrl.protocol === proxyServerProtocol && parsedUrl.hostname === proxyHostname && parsedUrl.port === proxyPort) {
						    var parsedDestLocation = destLocation.getParsed();
						    parsedUrl.protocol = parsedDestLocation.protocol;
						    parsedUrl.host = parsedDestLocation.host;
						    parsedUrl.hostname = parsedDestLocation.hostname;
						    parsedUrl.port = parsedDestLocation.port || '';
						    resolvedUrl = sharedUrlUtils.formatUrl(parsedUrl);
						  }
						  /*eslint-enable no-restricted-properties*/


						  if (parsedResourceType.isWebSocket) {
						    // eslint-disable-next-line no-restricted-properties
						    parsedUrl.protocol = parsedUrl.protocol.replace('ws', 'http');
						    resolvedUrl = sharedUrlUtils.formatUrl(parsedUrl);
						    reqOrigin = reqOrigin || destLocation.getOriginHeader();
						  }

						  return sharedUrlUtils.getProxyUrl(resolvedUrl, {
						    proxyProtocol: proxyProtocol,
						    proxyHostname: proxyHostname,
						    proxyPort: proxyPort,
						    sessionId: sessionId,
						    resourceType: resourceType,
						    charset: charset,
						    reqOrigin: reqOrigin,
						    windowId: windowId,
						    credentials: credentials
						  });
						}

						exports.getProxyUrl = getProxyUrl;

						function getNavigationUrl(url, win) {
						  // NOTE: For the 'about:blank' page, we perform url proxing only for the top window, 'location' object and links.
						  // For images and iframes, we keep urls as they were.
						  // See details in https://github.com/DevExpress/testcafe-hammerhead/issues/339
						  var destinationLocation = null;
						  var isIframe = win.top !== win;
						  var winLocation = win.location.toString();
						  if (isIframe) destinationLocation = winLocation;else {
						    var parsedProxyUrl = parseProxyUrl(winLocation);
						    destinationLocation = parsedProxyUrl && parsedProxyUrl.destUrl;
						  }
						  if (isSpecialPage(destinationLocation) && sharedUrlUtils.isRelativeUrl(url)) return '';
						  url = sharedUrlUtils.prepareUrl(url);
						  return getProxyUrl(url);
						}

						exports.getNavigationUrl = getNavigationUrl;

						function getCrossDomainIframeProxyUrl(url) {
						  return getProxyUrl(url, {
						    proxyPort: settings_1.default.get().crossDomainProxyPort,
						    resourceType: sharedUrlUtils.getResourceTypeString({
						      isIframe: true
						    })
						  });
						}

						exports.getCrossDomainIframeProxyUrl = getCrossDomainIframeProxyUrl;

						function getPageProxyUrl(url, windowId) {
						  var parsedProxyUrl = parseProxyUrl(url);
						  var resourceType = null;

						  if (parsedProxyUrl) {
						    url = parsedProxyUrl.destUrl;
						    resourceType = parsedProxyUrl.resourceType;
						  }

						  if (resourceType) {
						    var parsedResourceType = parseResourceType(resourceType);
						    parsedResourceType.isIframe = false;
						    resourceType = stringifyResourceType(parsedResourceType);
						  }

						  var isCrossDomainUrl = !destLocation.sameOriginCheck(destLocation.getLocation(), url);
						  var proxyPort = isCrossDomainUrl ? settings_1.default.get().crossDomainProxyPort : location.port.toString(); // eslint-disable-line no-restricted-properties

						  return getProxyUrl(url, {
						    windowId: windowId,
						    proxyPort: proxyPort,
						    resourceType: resourceType
						  });
						}

						exports.getPageProxyUrl = getPageProxyUrl;

						function getCrossDomainProxyPort(proxyPort) {
						  return settings_1.default.get().crossDomainProxyPort === proxyPort // eslint-disable-next-line no-restricted-properties
						  ? location.port.toString() : settings_1.default.get().crossDomainProxyPort;
						}

						exports.getCrossDomainProxyPort = getCrossDomainProxyPort;

						function resolveUrlAsDest(url) {
						  return sharedUrlUtils.resolveUrlAsDest(url, getProxyUrl);
						}

						exports.resolveUrlAsDest = resolveUrlAsDest;

						function formatUrl(parsedUrl) {
						  return sharedUrlUtils.formatUrl(parsedUrl);
						}

						exports.formatUrl = formatUrl;

						function parseProxyUrl(proxyUrl) {
						  return sharedUrlUtils.parseProxyUrl(proxyUrl);
						}

						exports.parseProxyUrl = parseProxyUrl;

						function parseUrl(url) {
						  return sharedUrlUtils.parseUrl(url);
						}

						exports.parseUrl = parseUrl;

						function convertToProxyUrl(url, resourceType, charset, isCrossDomain) {
						  if (isCrossDomain === void 0) {
						    isCrossDomain = false;
						  }

						  return getProxyUrl(url, {
						    resourceType: resourceType,
						    charset: charset,
						    // eslint-disable-next-line no-restricted-properties
						    proxyPort: isCrossDomain ? settings_1.default.get().crossDomainProxyPort : exports.DEFAULT_PROXY_SETTINGS.port
						  });
						}

						exports.convertToProxyUrl = convertToProxyUrl;

						function changeDestUrlPart(proxyUrl, nativePropSetter, value, resourceType) {
						  var parsed = sharedUrlUtils.parseProxyUrl(proxyUrl);

						  if (parsed) {
						    var sessionId = parsed.sessionId;
						    var proxy = parsed.proxy; // @ts-ignore

						    var destUrl = urlResolver.changeUrlPart(parsed.destUrl, nativePropSetter, value, document);
						    return getProxyUrl(destUrl, {
						      /*eslint-disable no-restricted-properties*/
						      proxyHostname: proxy.hostname,
						      proxyPort: proxy.port,

						      /*eslint-enable no-restricted-properties*/
						      sessionId: sessionId,
						      resourceType: resourceType
						    });
						  }

						  return proxyUrl;
						}

						exports.changeDestUrlPart = changeDestUrlPart;

						function isValidWebSocketUrl(url) {
						  var resolvedUrl = resolveUrlAsDest(url);
						  return SUPPORTED_WEB_SOCKET_PROTOCOL_RE.test(resolvedUrl);
						}

						exports.isValidWebSocketUrl = isValidWebSocketUrl;

						function isSubDomain(domain, subDomain) {
						  return sharedUrlUtils.isSubDomain(domain, subDomain);
						}

						exports.isSubDomain = isSubDomain;

						function isSupportedProtocol(url) {
						  return sharedUrlUtils.isSupportedProtocol(url);
						}

						exports.isSupportedProtocol = isSupportedProtocol;

						function isSpecialPage(url) {
						  return sharedUrlUtils.isSpecialPage(url);
						}

						exports.isSpecialPage = isSpecialPage;

						function parseResourceType(resourceType) {
						  return sharedUrlUtils.parseResourceType(resourceType);
						}

						exports.parseResourceType = parseResourceType;

						function stringifyResourceType(resourceType) {
						  return sharedUrlUtils.getResourceTypeString(resourceType);
						}

						exports.stringifyResourceType = stringifyResourceType;

						function isChangedOnlyHash(currentUrl, newUrl) {
						  // NOTE: we compare proxied urls because urls passed into the function may be proxied, non-proxied
						  // or relative. The getProxyUrl function solves all the corresponding problems.
						  return getProxyUrl(currentUrl).replace(HASH_RE, '') === getProxyUrl(newUrl).replace(HASH_RE, '');
						}

						exports.isChangedOnlyHash = isChangedOnlyHash;

						function getDestinationUrl(proxyUrl) {
						  var parsedProxyUrl = parseProxyUrl(proxyUrl);
						  return parsedProxyUrl ? parsedProxyUrl.destUrl : proxyUrl;
						}

						exports.getDestinationUrl = getDestinationUrl;

						function getScope(url) {
						  if (!isSupportedProtocol(url)) return null;
						  var parsedUrl = parseUrl(resolveUrlAsDest(url));
						  if (!parsedUrl) return null;
						  return parsedUrl.partAfterHost.replace(SCOPE_RE, '/') || '/';
						}

						exports.getScope = getScope;

						function getAjaxProxyUrl(url, credentials) {
						  var isCrossDomain = !destination_location_1.sameOriginCheck(destination_location_1.getLocation(), url);
						  var opts = {
						    resourceType: stringifyResourceType({
						      isAjax: true
						    }),
						    credentials: credentials
						  };

						  if (isCrossDomain) {
						    opts.proxyPort = settings_1.default.get().crossDomainProxyPort;
						    opts.reqOrigin = destLocation.getOriginHeader();
						  }

						  return getProxyUrl(url, opts);
						}

						exports.getAjaxProxyUrl = getAjaxProxyUrl;
					}
				},
				"worker": {
					"fetch-event.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var event_1 = require("../utils/event");

						var url_1 = require("../utils/url");

						var set_settings_command_1 = require("./set-settings-command");

						var instruction_1 = __importDefault(require("../../processing/script/instruction"));
						/*eslint-disable*/


						var swFetchCheckSettings = {
						  protocol: '',
						  host: '',
						  scope: ''
						};

						function isCorrectScope(parsedUrl) {
						  return parsedUrl.protocol === swFetchCheckSettings.protocol && parsedUrl.host === swFetchCheckSettings.host && parsedUrl.partAfterHost.startsWith(swFetchCheckSettings.scope);
						}

						function overrideFetchEvent() {
						  var waitSettingsPromise = new Promise(function (resolve, reject) {
						    native_methods_1.default.windowAddEventListener.call(self, 'message', function onMessage(e
						    /*ExtendableMessageEvent*/
						    ) {
						      var data = e.data;
						      if (data.cmd !== set_settings_command_1.SET_SERVICE_WORKER_SETTINGS) return;
						      var swScopeHeaderExists = self[instruction_1.default.swScopeHeaderValue] !== void 0;
						      var currentScope = swScopeHeaderExists ? self[instruction_1.default.swScopeHeaderValue] : data.currentScope;
						      var scope = data.optsScope;
						      if (!scope) scope = currentScope;else if (!scope.startsWith(currentScope)) {
						        // @ts-ignore
						        self.registration.unregister();
						        var errorMessage = "The path of the provided scope ('" + data.optsScope + "') is not under the max " + ("scope allowed (" + (swScopeHeaderExists ? 'set by Service-Worker-Allowed: ' : '') + "'") + (currentScope + "'). Adjust the scope, move the Service Worker script, ") + 'or use the Service-Worker-Allowed HTTP header to allow the scope.';
						        e.ports[0].postMessage({
						          error: errorMessage
						        });
						        reject(new Error(errorMessage));
						        return;
						      }
						      e.ports[0].postMessage({});
						      swFetchCheckSettings.protocol = data.protocol;
						      swFetchCheckSettings.host = data.host;
						      swFetchCheckSettings.scope = scope;
						      native_methods_1.default.windowRemoveEventListener.call(self, 'message', onMessage);
						      event_1.stopPropagation(e);
						      waitSettingsPromise = null;
						      resolve();
						    });
						  });
						  self.addEventListener('install', function (e
						  /*InstallEvent*/
						  ) {
						    return e.waitUntil(waitSettingsPromise);
						  });
						  native_methods_1.default.windowAddEventListener.call(self, 'fetch', function (e
						  /*FetchEvent*/
						  ) {
						    var request = e.request;
						    var proxyUrl = native_methods_1.default.requestUrlGetter.call(request);
						    var parsedProxyUrl = url_1.parseProxyUrl(proxyUrl);
						    var isInternalRequest = !parsedProxyUrl;

						    if (!isInternalRequest) {
						      // @ts-ignore Chrome has a non-standard the "iframe" destination
						      var isPage = request.destination === 'document' || request.destination === 'iframe';

						      if (isPage) {
						        if (isCorrectScope(parsedProxyUrl.destResourceInfo)) return;
						      } else {
						        var proxyReferrer = native_methods_1.default.requestReferrerGetter.call(request);
						        var parsedProxyReferrer = url_1.parseProxyUrl(proxyReferrer);
						        if (parsedProxyReferrer && isCorrectScope(parsedProxyReferrer.destResourceInfo)) return;
						      }
						    } // NOTE: This request should not have gotten into this service worker


						    e.respondWith(native_methods_1.default.fetch.call(self, request));
						    event_1.stopPropagation(e);
						  });
						}

						exports.default = overrideFetchEvent;
						module.exports = exports.default;
					},
					"index.js": function (exports, module, require) {
						

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						var __importStar = void 0 && (void 0).__importStar || function (mod) {
						  if (mod && mod.__esModule) return mod;
						  var result = {};
						  if (mod != null) for (var k in mod) {
						    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
						  }
						  result["default"] = mod;
						  return result;
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var pinkie_1 = __importDefault(require("pinkie"));

						var sharedUrlUtils = __importStar(require("../../utils/url"));

						var xhr_1 = __importDefault(require("../sandbox/xhr"));

						var fetch_1 = __importDefault(require("../sandbox/fetch"));

						var settings_1 = __importDefault(require("../settings"));

						var fetch_event_1 = __importDefault(require("./fetch-event"));

						var global_context_info_1 = __importDefault(require("../utils/global-context-info"));

						var noop_1 = __importDefault(require("../utils/noop"));

						var native_methods_1 = __importDefault(require("../sandbox/native-methods"));

						var set_settings_command_1 = require("./set-settings-command");

						var destination_location_1 = require("../utils/destination-location");

						var event_1 = require("../utils/event");

						var WorkerHammerhead = /*#__PURE__*/function () {
						  function WorkerHammerhead() {
						    var parsedLocation = sharedUrlUtils.parseProxyUrl(location.toString());
						    var cookieSandboxMock = {
						      syncCookie: noop_1.default
						    };
						    var waitHammerheadSettings = null; // NOTE: the blob location case

						    if (!parsedLocation) {
						      waitHammerheadSettings = new pinkie_1.default(function (resolve) {
						        native_methods_1.default.windowAddEventListener.call(self, 'message', function onMessage(e) {
						          var data = native_methods_1.default.messageEventDataGetter.call(e);
						          if (data.cmd !== set_settings_command_1.SET_BLOB_WORKER_SETTINGS) return;

						          WorkerHammerhead._setProxySettings(data.sessionId, data.windowId);

						          destination_location_1.forceLocation(data.origin); // eslint-disable-line no-restricted-properties

						          native_methods_1.default.windowRemoveEventListener.call(self, 'message', onMessage);
						          event_1.stopPropagation(e);
						          resolve();
						        });
						      });
						    } else WorkerHammerhead._setProxySettings(parsedLocation.sessionId, parsedLocation.windowId);

						    this.fetch = new fetch_1.default(cookieSandboxMock, waitHammerheadSettings);
						    this.fetch.attach(self);

						    if (!global_context_info_1.default.isServiceWorker) {
						      this.xhr = new xhr_1.default(cookieSandboxMock, waitHammerheadSettings);
						      this.xhr.attach(self);
						    } else fetch_event_1.default();
						  }

						  WorkerHammerhead._setProxySettings = function _setProxySettings(sessionId, windowId) {
						    var currentSettings = settings_1.default.get();
						    currentSettings.sessionId = sessionId;
						    currentSettings.windowId = windowId;
						    settings_1.default.set(currentSettings);
						  };

						  return WorkerHammerhead;
						}();

						exports.default = new WorkerHammerhead();
						module.exports = exports.default;
					},
					"sandbox-base-with-delayed-settings.js": function (exports, module, require) {
						

						function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

						function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

						var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
						  return mod && mod.__esModule ? mod : {
						    "default": mod
						  };
						};

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});

						var base_1 = __importDefault(require("../sandbox/base"));

						var SandboxBaseWithDelayedSettings = /*#__PURE__*/function (_base_1$default) {
						  _inheritsLoose(SandboxBaseWithDelayedSettings, _base_1$default);

						  function SandboxBaseWithDelayedSettings(_waitHammerheadSettings) {
						    var _this;

						    _this = _base_1$default.call(this) || this;
						    _this._waitHammerheadSettings = _waitHammerheadSettings;

						    if (_waitHammerheadSettings) {
						      _waitHammerheadSettings.then(function () {
						        _this._waitHammerheadSettings = null;
						      });
						    }

						    return _this;
						  }

						  var _proto = SandboxBaseWithDelayedSettings.prototype;

						  _proto.gettingSettingInProgress = function gettingSettingInProgress() {
						    return !!this._waitHammerheadSettings;
						  };

						  _proto.delayUntilGetSettings = function delayUntilGetSettings(action) {
						    return this._waitHammerheadSettings.then(action);
						  };

						  return SandboxBaseWithDelayedSettings;
						}(base_1.default);

						exports.default = SandboxBaseWithDelayedSettings;
						module.exports = exports.default;
					},
					"set-settings-command.js": function (exports, module, require) {
						

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});
						exports.SET_SERVICE_WORKER_SETTINGS = 'hammerhead|set-service-worker-settings';
						exports.SET_BLOB_WORKER_SETTINGS = 'hammerhead|set-blob-worker-settings';
					}
				}
			},
			"processing": {
				"dom": {
					"internal-attributes.js": function (exports, module, require) {
						 // -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});
						exports.default = {
						  storedAttrPostfix: '-hammerhead-stored-value',
						  hoverPseudoClass: 'data-hammerhead-hovered',
						  focusPseudoClass: 'data-hammerhead-focused',
						  uploadInfoHiddenInputName: 'hammerhead|upload-info-hidden-input-name'
						};
						module.exports = exports.default;
					},
					"internal-properties.js": function (exports, module, require) {
						 // -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});
						exports.default = {
						  processDomMethodName: 'hammerhead|process-dom-method',
						  processedContext: 'hammerhead|processed-context',
						  documentWasCleaned: 'hammerhead|document-was-cleaned',
						  documentCharset: 'hammerhead|document-charset',
						  iframeNativeMethods: 'hammerhead|iframe-native-methods',
						  hammerhead: '%hammerhead%',
						  selection: 'hammerhead|selection',
						  shadowUIElement: 'hammerhead|shadow-ui-element',
						  forceProxySrcForImage: 'hammerhead|image|force-proxy-src-flag',
						  skipNextLoadEventForImage: 'hammerhead|image|skip-next-load-event-flag',
						  cachedImage: 'hammerhead|image|cached-image',
						  sandboxIsReattached: 'hammerhead|sandbox-is-reattached',
						  nativeStrRepresentation: 'hammerhead|native-string-representation'
						};
						module.exports = exports.default;
					}
				},
				"script": {
					"instruction.js": function (exports, module, require) {
						 // -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						Object.defineProperty(exports, "__esModule", {
						  value: true
						});
						exports.default = {
						  getLocation: '__get$Loc',
						  setLocation: '__set$Loc',
						  getProperty: '__get$',
						  setProperty: '__set$',
						  callMethod: '__call$',
						  processScript: '__proc$Script',
						  processHtml: '__proc$Html',
						  getEval: '__get$Eval',
						  getPostMessage: '__get$PostMessage',
						  getProxyUrl: '__get$ProxyUrl',
						  restArray: '__rest$Array',
						  restObject: '__rest$Object',
						  swScopeHeaderValue: '__swScopeHeaderValue'
						};
						module.exports = exports.default;
					}
				}
			},
			"request-pipeline": {
				"builtin-header-names.js": function (exports, module, require) {
					 // -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					/* eslint hammerhead/proto-methods: 2 */

					Object.defineProperty(exports, "__esModule", {
					  value: true
					});
					exports.default = {
					  authorization: 'authorization',
					  wwwAuthenticate: 'www-authenticate',
					  proxyAuthorization: 'proxy-authorization',
					  proxyAuthenticate: 'proxy-authenticate',
					  host: 'host',
					  referer: 'referer',
					  origin: 'origin',
					  contentLength: 'content-length',
					  cookie: 'cookie',
					  setCookie: 'set-cookie',
					  ifModifiedSince: 'if-modified-since',
					  ifNoneMatch: 'if-none-match',
					  contentType: 'content-type',
					  location: 'location',
					  xFrameOptions: 'x-frame-options',
					  sourceMap: 'sourcemap',
					  referrerPolicy: 'referrer-policy',
					  refresh: 'refresh',
					  link: 'link',
					  cacheControl: 'cache-control',
					  pragma: 'pragma',
					  eTag: 'etag',
					  contentDisposition: 'content-disposition',
					  accept: 'accept',
					  contentEncoding: 'content-encoding',
					  expires: 'expires',
					  serviceWorkerAllowed: 'service-worker-allowed',
					  accessControlAllowOrigin: 'access-control-allow-origin',
					  accessControlAllowCredentials: 'access-control-allow-credentials',
					  contentSecurityPolicy: 'content-security-policy',
					  contentSecurityPolicyReportOnly: 'content-security-policy-report-only',
					  xContentSecurityPolicy: 'x-content-security-policy',
					  xContentSecurityPolicyReportOnly: 'x-content-security-policy-report-only',
					  xWebkitCsp: 'x-webkit-csp'
					};
					module.exports = exports.default;
				}
			},
			"shadow-ui": {
				"class-name.js": function (exports, module, require) {
					 // -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					/* eslint hammerhead/proto-methods: 2 */

					Object.defineProperty(exports, "__esModule", {
					  value: true
					});
					var POSTFIX = '-hammerhead-shadow-ui';
					exports.default = {
					  postfix: POSTFIX,
					  charset: 'charset' + POSTFIX,
					  script: 'script' + POSTFIX,
					  selfRemovingScript: 'self-removing-script' + POSTFIX,
					  uiStylesheet: 'ui-stylesheet' + POSTFIX
					};
					module.exports = exports.default;
				}
			},
			"utils": {
				"headers.js": function (exports, module, require) {
					 // -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
					  return mod && mod.__esModule ? mod : {
					    "default": mod
					  };
					};

					Object.defineProperty(exports, "__esModule", {
					  value: true
					});

					var builtin_header_names_1 = __importDefault(require("../request-pipeline/builtin-header-names"));

					var AUTHENTICATE_PREFIX = '~~~TestCafe added this prefix to hide the authentication dialog box~~~';
					var AUTHORIZATION_PREFIX = '~~~TestCafe added this prefix to control the authorization flow~~~';

					function addAuthenticatePrefix(value) {
					  return AUTHENTICATE_PREFIX + value;
					}

					exports.addAuthenticatePrefix = addAuthenticatePrefix;

					function hasAuthenticatePrefix(value) {
					  return value.indexOf(AUTHENTICATE_PREFIX) > -1;
					}

					exports.hasAuthenticatePrefix = hasAuthenticatePrefix;

					function removeAuthenticatePrefix(value) {
					  return value.replace(AUTHENTICATE_PREFIX, '');
					}

					exports.removeAuthenticatePrefix = removeAuthenticatePrefix;

					function isAuthenticateHeader(headerName) {
					  var headerNameStr = String(headerName).toLowerCase();
					  return headerNameStr === builtin_header_names_1.default.wwwAuthenticate || headerNameStr === builtin_header_names_1.default.proxyAuthenticate;
					}

					exports.isAuthenticateHeader = isAuthenticateHeader;

					function addAuthorizationPrefix(value) {
					  return AUTHORIZATION_PREFIX + value;
					}

					exports.addAuthorizationPrefix = addAuthorizationPrefix;

					function hasAuthorizationPrefix(value) {
					  return value.indexOf(AUTHORIZATION_PREFIX) > -1;
					}

					exports.hasAuthorizationPrefix = hasAuthorizationPrefix;

					function removeAuthorizationPrefix(value) {
					  return value.replace(AUTHORIZATION_PREFIX, '');
					}

					exports.removeAuthorizationPrefix = removeAuthorizationPrefix;

					function isAuthorizationHeader(headerName) {
					  var headerNameStr = String(headerName).toLowerCase();
					  return headerNameStr === builtin_header_names_1.default.authorization || headerNameStr === builtin_header_names_1.default.proxyAuthorization;
					}

					exports.isAuthorizationHeader = isAuthorizationHeader;
				},
				"string-trim.js": function (exports, module, require) {
					 // -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					Object.defineProperty(exports, "__esModule", {
					  value: true
					}); // NOTE: Some websites override the String.prototype.trim method. When we use this function
					// in our scripts, we expect it to have the default behavior. Therefore, in order to protect
					// ourselves from spoofing, we must use our own implementation. Also, we cannot use the
					// String.prototype.trim method because on the client-side it is the same in the top window and
					// an iframe window. The client code may override this method in the top window before the
					// iframe is initialized, so that the iframe will lose access to the native method.

					function default_1(str) {
					  return typeof str === 'string' ? str.replace(/(^\s+)|(\s+$)/g, '') : str;
					}

					exports.default = default_1;
					module.exports = exports.default;
				},
				"url.js": function (exports, module, require) {
					 // -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
					  return mod && mod.__esModule ? mod : {
					    "default": mod
					  };
					};

					Object.defineProperty(exports, "__esModule", {
					  value: true
					});

					var string_trim_1 = __importDefault(require("./string-trim"));

					var PROTOCOL_RE = /^([\w-]+?:)(\/\/|[^\\/]|$)/;
					var LEADING_SLASHES_RE = /^(\/\/)/;
					var HOST_RE = /^(.*?)(\/|%|\?|;|#|$)/;
					var PORT_RE = /:([0-9]*)$/;
					var QUERY_AND_HASH_RE = /(\?.+|#[^#]*)$/;
					var PATH_AFTER_HOST_RE = /^\/([^/]+?)\/([\S\s]+)$/;
					var HTTP_RE = /^https?:/;
					var FILE_RE = /^file:/i;
					var SHORT_ORIGIN_RE = /^http(s)?:\/\//;
					var IS_SECURE_ORIGIN_RE = /^s\*/;
					exports.SUPPORTED_PROTOCOL_RE = /^(?:https?|file):/i;
					exports.HASH_RE = /^#/;
					exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = '!';
					exports.REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR = '*';
					exports.TRAILING_SLASH_RE = /\/$/;
					exports.SPECIAL_BLANK_PAGE = 'about:blank';
					exports.SPECIAL_ERROR_PAGE = 'about:error';
					exports.SPECIAL_PAGES = [exports.SPECIAL_BLANK_PAGE, exports.SPECIAL_ERROR_PAGE];
					exports.HTTP_DEFAULT_PORT = '80';
					exports.HTTPS_DEFAULT_PORT = '443';
					var Credentials;

					(function (Credentials) {
					  Credentials[Credentials["include"] = 0] = "include";
					  Credentials[Credentials["sameOrigin"] = 1] = "sameOrigin";
					  Credentials[Credentials["omit"] = 2] = "omit";
					  Credentials[Credentials["unknown"] = 3] = "unknown";
					})(Credentials = exports.Credentials || (exports.Credentials = {}));

					var SPECIAL_PAGE_DEST_RESOURCE_INFO = {
					  protocol: 'about:',
					  host: '',
					  hostname: '',
					  port: '',
					  partAfterHost: ''
					};
					var RESOURCE_TYPES = [{
					  name: 'isIframe',
					  flag: 'i'
					}, {
					  name: 'isForm',
					  flag: 'f'
					}, {
					  name: 'isScript',
					  flag: 's'
					}, {
					  name: 'isEventSource',
					  flag: 'e'
					}, {
					  name: 'isHtmlImport',
					  flag: 'h'
					}, {
					  name: 'isWebSocket',
					  flag: 'w'
					}, {
					  name: 'isServiceWorker',
					  flag: 'c'
					}, {
					  name: 'isAjax',
					  flag: 'a'
					}];

					function parseResourceType(resourceType) {
					  var parsedResourceType = {};
					  if (!resourceType) return parsedResourceType;

					  for (var _i2 = 0; _i2 < RESOURCE_TYPES.length; _i2++) {
					    var _RESOURCE_TYPES$_i = RESOURCE_TYPES[_i2],
					        name = _RESOURCE_TYPES$_i.name,
					        flag = _RESOURCE_TYPES$_i.flag;
					    if (resourceType.indexOf(flag) > -1) parsedResourceType[name] = true;
					  }

					  return parsedResourceType;
					}

					exports.parseResourceType = parseResourceType;

					function getResourceTypeString(parsedResourceType) {
					  if (!parsedResourceType) return null;
					  var resourceType = '';

					  for (var _i4 = 0; _i4 < RESOURCE_TYPES.length; _i4++) {
					    var _RESOURCE_TYPES$_i2 = RESOURCE_TYPES[_i4],
					        name = _RESOURCE_TYPES$_i2.name,
					        flag = _RESOURCE_TYPES$_i2.flag;
					    if (parsedResourceType[name]) resourceType += flag;
					  }

					  return resourceType || null;
					}

					exports.getResourceTypeString = getResourceTypeString;

					function makeShortOrigin(origin) {
					  return origin === 'null' ? '' : origin.replace(SHORT_ORIGIN_RE, function (_, secure) {
					    return secure ? 's*' : '';
					  });
					}

					function restoreShortOrigin(origin) {
					  if (!origin) return 'null';
					  return IS_SECURE_ORIGIN_RE.test(origin) ? origin.replace(IS_SECURE_ORIGIN_RE, 'https://') : 'http://' + origin;
					}

					exports.restoreShortOrigin = restoreShortOrigin;

					function isSubDomain(domain, subDomain) {
					  domain = domain.replace(/^www./i, '');
					  subDomain = subDomain.replace(/^www./i, '');
					  if (domain === subDomain) return true;
					  var index = subDomain.lastIndexOf(domain);
					  return subDomain[index - 1] === '.' && subDomain.length === index + domain.length;
					}

					exports.isSubDomain = isSubDomain;

					function sameOriginCheck(location, checkedUrl) {
					  if (!checkedUrl) return true;
					  var parsedCheckedUrl = parseUrl(checkedUrl);
					  var isRelative = !parsedCheckedUrl.host;
					  if (isRelative) return true;
					  var parsedLocation = parseUrl(location);
					  var parsedProxyLocation = parseProxyUrl(location);
					  if (parsedCheckedUrl.host === parsedLocation.host && parsedCheckedUrl.protocol === parsedLocation.protocol) return true;
					  var parsedDestUrl = parsedProxyLocation ? parsedProxyLocation.destResourceInfo : parsedLocation;
					  if (!parsedDestUrl) return false;
					  var isSameProtocol = !parsedCheckedUrl.protocol || parsedCheckedUrl.protocol === parsedDestUrl.protocol;
					  var portsEq = !parsedDestUrl.port && !parsedCheckedUrl.port || parsedDestUrl.port && parsedDestUrl.port.toString() === parsedCheckedUrl.port;
					  return isSameProtocol && !!portsEq && parsedDestUrl.hostname === parsedCheckedUrl.hostname;
					}

					exports.sameOriginCheck = sameOriginCheck; // NOTE: Convert the destination protocol and hostname to the lower case. (GH-1)

					function convertHostToLowerCase(url) {
					  var parsedUrl = parseUrl(url);
					  parsedUrl.protocol = parsedUrl.protocol && parsedUrl.protocol.toLowerCase();
					  parsedUrl.host = parsedUrl.host && parsedUrl.host.toLowerCase();
					  return formatUrl(parsedUrl);
					}

					function getURLString(url) {
					  // TODO: fix it
					  // eslint-disable-next-line no-undef
					  if (url === null && /iPad|iPhone/i.test(window.navigator.userAgent)) return '';
					  return String(url).replace(/\n|\t/g, '');
					}

					exports.getURLString = getURLString;

					function getProxyUrl(url, opts) {
					  var sessionInfo = [opts.sessionId];
					  if (opts.windowId) sessionInfo.push(opts.windowId);
					  var params = [sessionInfo.join(exports.REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR)];
					  if (opts.resourceType) params.push(opts.resourceType);
					  if (opts.charset) params.push(opts.charset.toLowerCase());
					  if (typeof opts.credentials === 'number') params.push(opts.credentials.toString());
					  if (opts.reqOrigin) params.push(encodeURIComponent(makeShortOrigin(opts.reqOrigin)));
					  var descriptor = params.join(exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR);
					  var proxyProtocol = opts.proxyProtocol || 'http:';
					  return proxyProtocol + "//" + opts.proxyHostname + ":" + opts.proxyPort + "/" + descriptor + "/" + convertHostToLowerCase(url);
					}

					exports.getProxyUrl = getProxyUrl;

					function getDomain(parsed) {
					  if (parsed.protocol === 'file:') return 'null';
					  return formatUrl({
					    protocol: parsed.protocol,
					    host: parsed.host,
					    hostname: parsed.hostname,
					    port: String(parsed.port || '')
					  });
					}

					exports.getDomain = getDomain;

					function parseRequestDescriptor(desc) {
					  var _desc$split = desc.split(exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR),
					      sessionInfo = _desc$split[0],
					      resourceType = _desc$split[1],
					      resourceData = _desc$split.slice(2);

					  if (!sessionInfo) return null;

					  var _sessionInfo$split = sessionInfo.split(exports.REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR),
					      sessionId = _sessionInfo$split[0],
					      windowId = _sessionInfo$split[1];

					  var parsedDesc = {
					    sessionId: sessionId,
					    resourceType: resourceType || null
					  };
					  if (windowId) parsedDesc.windowId = windowId;

					  if (resourceType && resourceData.length) {
					    var parsedResourceType = parseResourceType(resourceType);
					    if (parsedResourceType.isScript || parsedResourceType.isServiceWorker) parsedDesc.charset = resourceData[0];else if (parsedResourceType.isWebSocket) parsedDesc.reqOrigin = decodeURIComponent(restoreShortOrigin(resourceData[0]));else if (parsedResourceType.isAjax) {
					      parsedDesc.credentials = parseInt(resourceData[0]);
					      if (resourceData.length === 2) parsedDesc.reqOrigin = decodeURIComponent(restoreShortOrigin(resourceData[1]));
					    }
					  }

					  return parsedDesc;
					}

					function parseProxyUrl(proxyUrl) {
					  // TODO: Remove it.
					  var parsedUrl = parseUrl(proxyUrl);
					  if (!parsedUrl.partAfterHost) return null;
					  var match = parsedUrl.partAfterHost.match(PATH_AFTER_HOST_RE);
					  if (!match) return null;
					  var parsedDesc = parseRequestDescriptor(match[1]); // NOTE: We should have, at least, the job uid and the owner token.

					  if (!parsedDesc) return null;
					  var destUrl = match[2]; // Browser can redirect to a special page with hash (GH-1671)

					  var destUrlWithoutHash = destUrl.replace(/#[\S\s]*$/, '');
					  if (!isSpecialPage(destUrlWithoutHash) && !exports.SUPPORTED_PROTOCOL_RE.test(destUrl)) return null;
					  var destResourceInfo = null;
					  if (isSpecialPage(destUrlWithoutHash)) destResourceInfo = SPECIAL_PAGE_DEST_RESOURCE_INFO;else {
					    destUrl = omitDefaultPort(destUrl);
					    destResourceInfo = parseUrl(destUrl);
					  }
					  return {
					    destUrl: destUrl,
					    destResourceInfo: destResourceInfo,
					    partAfterHost: parsedUrl.partAfterHost,
					    proxy: {
					      hostname: parsedUrl.hostname,
					      port: parsedUrl.port
					    },
					    sessionId: parsedDesc.sessionId,
					    resourceType: parsedDesc.resourceType,
					    charset: parsedDesc.charset,
					    reqOrigin: parsedDesc.reqOrigin,
					    windowId: parsedDesc.windowId,
					    credentials: parsedDesc.credentials
					  };
					}

					exports.parseProxyUrl = parseProxyUrl;

					function getPathname(path) {
					  return path.replace(QUERY_AND_HASH_RE, '');
					}

					exports.getPathname = getPathname;

					function parseUrl(url) {
					  var parsed = {};
					  url = processSpecialChars(url);
					  if (!url) return parsed;
					  url = string_trim_1.default(url); // Protocol

					  var hasImplicitProtocol = false;
					  var remainder = url.replace(PROTOCOL_RE, function (_str, protocol, strAfterProtocol) {
					    parsed.protocol = protocol;
					    return strAfterProtocol;
					  }).replace(LEADING_SLASHES_RE, function () {
					    hasImplicitProtocol = true;
					    return '';
					  }); // NOTE: the URL is relative.

					  if (!parsed.protocol && !hasImplicitProtocol) {
					    parsed.partAfterHost = url;
					    return parsed;
					  } // Host


					  parsed.partAfterHost = remainder.replace(HOST_RE, function (_str, host, restPartSeparator) {
					    parsed.host = host;
					    parsed.port = '';
					    return restPartSeparator;
					  });

					  if (typeof parsed.host === 'string') {
					    var authHostArr = parsed.host.split('@');

					    if (authHostArr.length === 2) {
					      parsed.auth = authHostArr[0];
					      parsed.host = authHostArr[1];
					    }
					  }

					  parsed.hostname = parsed.host ? parsed.host.replace(PORT_RE, function (_str, port) {
					    parsed.port = port;
					    return '';
					  }) : '';
					  return parsed;
					}

					exports.parseUrl = parseUrl;

					function isSupportedProtocol(url) {
					  url = string_trim_1.default(url || '');
					  var isHash = exports.HASH_RE.test(url);
					  if (isHash) return false;
					  var protocol = url.match(PROTOCOL_RE);
					  if (!protocol) return true;
					  return exports.SUPPORTED_PROTOCOL_RE.test(protocol[0]);
					}

					exports.isSupportedProtocol = isSupportedProtocol;

					function resolveUrlAsDest(url, getProxyUrlMeth) {
					  getProxyUrlMeth = getProxyUrlMeth || getProxyUrl;

					  if (isSupportedProtocol(url)) {
					    var proxyUrl = getProxyUrlMeth(url);
					    var parsedProxyUrl = parseProxyUrl(proxyUrl);
					    return parsedProxyUrl ? formatUrl(parsedProxyUrl.destResourceInfo) : url;
					  }

					  return url;
					}

					exports.resolveUrlAsDest = resolveUrlAsDest;

					function formatUrl(parsedUrl) {
					  // NOTE: the URL is relative.
					  if (parsedUrl.protocol !== 'file:' && !parsedUrl.host && (!parsedUrl.hostname || !parsedUrl.port)) return parsedUrl.partAfterHost;
					  var url = parsedUrl.protocol || '';
					  if (parsedUrl.protocol !== 'about:') url += '//';
					  if (parsedUrl.auth) url += parsedUrl.auth + '@';
					  if (parsedUrl.host) url += parsedUrl.host;else {
					    url += parsedUrl.hostname;
					    if (parsedUrl.port) url += ':' + parsedUrl.port;
					  }
					  if (parsedUrl.partAfterHost) url += parsedUrl.partAfterHost;
					  return url;
					}

					exports.formatUrl = formatUrl;

					function correctMultipleSlashes(url, pageProtocol) {
					  if (pageProtocol === void 0) {
					    pageProtocol = '';
					  }

					  // NOTE: Remove unnecessary slashes from the beginning of the url and after scheme.
					  // For example:
					  // "//////example.com" -> "//example.com" (scheme-less HTTP(S) URL)
					  // "////home/testcafe/documents" -> "///home/testcafe/documents" (scheme-less unix file URL)
					  // "http:///example.com" -> "http://example.com"
					  //
					  // And add missing slashes after the file scheme.
					  // "file://C:/document.txt" -> "file:///C:/document.txt"
					  if (url.match(FILE_RE) || pageProtocol.match(FILE_RE)) {
					    return url.replace(/^(file:)?\/+(\/\/\/.*$)/i, '$1$2').replace(/^(file:)?\/*([A-Za-z]):/i, '$1///$2:');
					  }

					  return url.replace(/^(https?:)?\/+(\/\/.*$)/i, '$1$2');
					}

					exports.correctMultipleSlashes = correctMultipleSlashes;

					function processSpecialChars(url) {
					  return correctMultipleSlashes(getURLString(url));
					}

					exports.processSpecialChars = processSpecialChars;

					function ensureTrailingSlash(srcUrl, processedUrl) {
					  if (!isValidUrl(processedUrl)) return processedUrl;
					  var srcUrlEndsWithTrailingSlash = exports.TRAILING_SLASH_RE.test(srcUrl);
					  var processedUrlEndsWithTrailingSlash = exports.TRAILING_SLASH_RE.test(processedUrl);
					  if (srcUrlEndsWithTrailingSlash && !processedUrlEndsWithTrailingSlash) processedUrl += '/';else if (srcUrl && !srcUrlEndsWithTrailingSlash && processedUrlEndsWithTrailingSlash) processedUrl = processedUrl.replace(exports.TRAILING_SLASH_RE, '');
					  return processedUrl;
					}

					exports.ensureTrailingSlash = ensureTrailingSlash;

					function isSpecialPage(url) {
					  return exports.SPECIAL_PAGES.indexOf(url) !== -1;
					}

					exports.isSpecialPage = isSpecialPage;

					function isRelativeUrl(url) {
					  var parsedUrl = parseUrl(url);
					  return parsedUrl.protocol !== 'file:' && !parsedUrl.host;
					}

					exports.isRelativeUrl = isRelativeUrl;

					function isValidPort(port) {
					  var parsedPort = parseInt(port, 10);
					  return parsedPort > 0 && parsedPort <= 65535;
					}

					function isValidUrl(url) {
					  var parsedUrl = parseUrl(url);
					  return parsedUrl.protocol === 'file:' || !!parsedUrl.hostname && (!parsedUrl.port || isValidPort(parsedUrl.port));
					}

					exports.isValidUrl = isValidUrl;

					function ensureOriginTrailingSlash(url) {
					  // NOTE: If you request an url containing only port, host and protocol
					  // then browser adds the trailing slash itself.
					  var parsedUrl = parseUrl(url);
					  if (!parsedUrl.partAfterHost && HTTP_RE.test(parsedUrl.protocol)) return url + '/';
					  return url;
					}

					exports.ensureOriginTrailingSlash = ensureOriginTrailingSlash;

					function omitDefaultPort(url) {
					  // NOTE: If you request an url containing default port
					  // then browser remove this one itself.
					  var parsedUrl = parseUrl(url);
					  var hasDefaultPort = parsedUrl.protocol === 'https:' && parsedUrl.port === exports.HTTPS_DEFAULT_PORT || parsedUrl.protocol === 'http:' && parsedUrl.port === exports.HTTP_DEFAULT_PORT;

					  if (hasDefaultPort) {
					    parsedUrl.host = parsedUrl.hostname;
					    parsedUrl.port = '';
					    return formatUrl(parsedUrl);
					  }

					  return url;
					}

					exports.omitDefaultPort = omitDefaultPort;

					function prepareUrl(url) {
					  url = omitDefaultPort(url);
					  url = ensureOriginTrailingSlash(url);
					  return url;
					}

					exports.prepareUrl = prepareUrl;

					function updateScriptImportUrls(cachedScript, serverInfo, sessionId, windowId) {
					  var regExp = new RegExp('(' + serverInfo.protocol + '//' + serverInfo.hostname + ':(?:' + serverInfo.port + '|' + serverInfo.crossDomainPort + ')/)[^/' + exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR + ']+', 'g');
					  var pattern = '$1' + sessionId + (windowId ? exports.REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR + windowId : '');
					  return cachedScript.replace(regExp, pattern);
					}

					exports.updateScriptImportUrls = updateScriptImportUrls;
				}
			}
		}
	}
})("testcafe-hammerhead/src/client/worker/index");

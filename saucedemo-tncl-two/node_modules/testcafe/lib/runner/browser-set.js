"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const time_limit_promise_1 = __importDefault(require("time-limit-promise"));
const promisify_event_1 = __importDefault(require("promisify-event"));
const lodash_1 = require("lodash");
// @ts-ignore
const map_reverse_1 = __importDefault(require("map-reverse"));
const runtime_1 = require("../errors/runtime");
const types_1 = require("../errors/types");
const status_1 = __importDefault(require("../browser/connection/status"));
const get_hints_1 = __importDefault(require("../browser/connection/get-hints"));
const string_1 = require("../utils/string");
const RELEASE_TIMEOUT = 10000;
class BrowserSet extends events_1.EventEmitter {
    constructor(browserConnectionGroups, options) {
        super();
        this._pendingReleases = [];
        this.browserConnectionGroups = browserConnectionGroups;
        this._browserConnections = lodash_1.flatten(browserConnectionGroups);
        this._options = options;
        this._browserErrorHandler = (error) => this.emit('error', error);
        this._browserConnections.forEach(bc => bc.on('error', this._browserErrorHandler));
        // NOTE: We're setting an empty error handler, because Node kills the process on an 'error' event
        // if there is no handler. See: https://nodejs.org/api/events.html#events_class_events_eventemitter
        this.on('error', lodash_1.noop);
    }
    static async _waitIdle(bc) {
        if (bc.idle || !bc.isReady())
            return;
        await promisify_event_1.default(bc, 'idle');
    }
    static async _closeConnection(bc) {
        if (bc.status === status_1.default.closed || bc.status === status_1.default.closing)
            return;
        await bc.close();
    }
    async _waitConnectionOpened(bc) {
        const openedTimeout = this._options.browserInitTimeout || await bc.getDefaultBrowserInitTimeout();
        const timeoutErr = new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection);
        const openedOrError = Promise.race([
            promisify_event_1.default(this, 'error'),
            promisify_event_1.default(bc, 'opened')
        ]);
        return time_limit_promise_1.default(openedOrError, openedTimeout, { rejectWith: timeoutErr });
    }
    async _waitConnectionsOpened() {
        return Promise.all(this._browserConnections
            .filter(bc => bc.status !== status_1.default.opened)
            .map(notOpenedConnection => this._waitConnectionOpened(notOpenedConnection)));
    }
    _checkForDisconnections() {
        const disconnectedUserAgents = this._browserConnections
            .filter(bc => bc.status === status_1.default.closed)
            .map(bc => bc.userAgent);
        if (disconnectedUserAgents.length)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers, disconnectedUserAgents.join(', '));
    }
    async prepareConnections() {
        await this._checkForDisconnections();
        await this._waitConnectionsOpened();
    }
    // NOTE: creates and prepares BrowserSet instance with given browser connections
    static async from(browserConnections, opts) {
        const browserSet = new BrowserSet(browserConnections, opts);
        try {
            const prepareConnections = browserSet.prepareConnections();
            const browserSetError = promisify_event_1.default(browserSet, 'error');
            await Promise.race([prepareConnections, browserSetError]);
            return browserSet;
        }
        catch (e) {
            const finalError = e.code === types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection
                ? browserSet.createBrowserConnectionError(e)
                : e;
            await browserSet.dispose();
            throw finalError;
        }
    }
    createBrowserConnectionError(error) {
        const notOpenedConnections = this._browserConnections.filter(bc => bc.status !== status_1.default.opened);
        const numOfAllConnections = this._browserConnections.length;
        const numOfNotOpenedConnections = notOpenedConnections.length;
        const listOfNotOpenedConnections = string_1.createList(notOpenedConnections.map(bc => bc.browserInfo.alias));
        const listOfHints = string_1.createList(get_hints_1.default(this._browserConnections, this._options));
        return new runtime_1.BrowserConnectionError(error.message, numOfNotOpenedConnections, numOfAllConnections, listOfNotOpenedConnections, listOfHints);
    }
    releaseConnection(bc) {
        if (!this._browserConnections.includes(bc))
            return Promise.resolve();
        lodash_1.pull(this._browserConnections, bc);
        bc.removeListener('error', this._browserErrorHandler);
        const appropriateStateSwitch = bc.permanent ?
            BrowserSet._waitIdle(bc) :
            BrowserSet._closeConnection(bc);
        const release = time_limit_promise_1.default(appropriateStateSwitch, RELEASE_TIMEOUT)
            .then(() => lodash_1.pull(this._pendingReleases, release));
        this._pendingReleases.push(release);
        return release;
    }
    async dispose() {
        // NOTE: When browserConnection is cancelled, it is removed from
        // the this.connections array, which leads to shifting indexes
        // towards the beginning. So, we must copy the array in order to iterate it,
        // or we can perform iteration from the end to the beginning.
        map_reverse_1.default(this._browserConnections, (bc) => this.releaseConnection(bc));
        await Promise.all(this._pendingReleases);
    }
}
exports.default = BrowserSet;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvd3Nlci1zZXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcnVubmVyL2Jyb3dzZXItc2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsbUNBQXNDO0FBQ3RDLDRFQUF1RDtBQUN2RCxzRUFBNkM7QUFDN0MsbUNBSWdCO0FBRWhCLGFBQWE7QUFDYiw4REFBcUM7QUFDckMsK0NBQXlFO0FBQ3pFLDJDQUFpRDtBQUVqRCwwRUFBbUU7QUFFbkUsZ0ZBQXdFO0FBQ3hFLDRDQUE2QztBQUU3QyxNQUFNLGVBQWUsR0FBRyxLQUFLLENBQUM7QUFFOUIsTUFBcUIsVUFBVyxTQUFRLHFCQUFZO0lBT2hELFlBQW9CLHVCQUE4QyxFQUFFLE9BQTBCO1FBQzFGLEtBQUssRUFBRSxDQUFDO1FBRVIsSUFBSSxDQUFDLGdCQUFnQixHQUFXLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsdUJBQXVCLEdBQUksdUJBQXVCLENBQUM7UUFDeEQsSUFBSSxDQUFDLG1CQUFtQixHQUFRLGdCQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsUUFBUSxHQUFtQixPQUFPLENBQUM7UUFFeEMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLENBQUMsS0FBWSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV4RSxJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztRQUVsRixpR0FBaUc7UUFDakcsbUdBQW1HO1FBQ25HLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLGFBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFTyxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBRSxFQUFxQjtRQUNqRCxJ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QUFFLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUV0RCxNQUFNLHNCQUFzQixHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUN6QyxVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDMUIsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXBDLE1BQU0sT0FBTyxHQUFHLDRCQUFxQixDQUFDLHNCQUFzQixFQUFFLGVBQWUsQ0FBQzthQUN6RSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsYUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsQ0FBa0IsQ0FBQztRQUV6RSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXBDLE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7SUFFTSxLQUFLLENBQUMsT0FBTztRQUNoQixnRUFBZ0U7UUFDaEUsOERBQThEO1FBQzlELDRFQUE0RTtRQUM1RSw2REFBNkQ7UUFDN0QscUJBQVUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxFQUFxQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUU1RixNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDN0MsQ0FBQztDQUNKO0FBN0lELDZCQTZJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgZ2V0VGltZUxpbWl0ZWRQcm9taXNlIGZyb20gJ3RpbWUtbGltaXQtcHJvbWlzZSc7XG5pbXBvcnQgcHJvbWlzaWZ5RXZlbnQgZnJvbSAncHJvbWlzaWZ5LWV2ZW50JztcbmltcG9ydCB7XG4gICAgZmxhdHRlbixcbiAgICBub29wLFxuICAgIHB1bGwgYXMgcmVtb3ZlXG59IGZyb20gJ2xvZGFzaCc7XG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBtYXBSZXZlcnNlIGZyb20gJ21hcC1yZXZlcnNlJztcbmltcG9ydCB7IEJyb3dzZXJDb25uZWN0aW9uRXJyb3IsIEdlbmVyYWxFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9ydW50aW1lJztcbmltcG9ydCB7IFJVTlRJTUVfRVJST1JTIH0gZnJvbSAnLi4vZXJyb3JzL3R5cGVzJztcbmltcG9ydCBCcm93c2VyQ29ubmVjdGlvbiBmcm9tICcuLi9icm93c2VyL2Nvbm5lY3Rpb24nO1xuaW1wb3J0IEJyb3dzZXJDb25uZWN0aW9uU3RhdHVzIGZyb20gJy4uL2Jyb3dzZXIvY29ubmVjdGlvbi9zdGF0dXMnO1xuaW1wb3J0IHsgQnJvd3NlclNldE9wdGlvbnMgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IGdldEJyb3dzZXJDb25uZWN0aW9uSGludHMgZnJvbSAnLi4vYnJvd3Nlci9jb25uZWN0aW9uL2dldC1oaW50cyc7XG5pbXBvcnQgeyBjcmVhdGVMaXN0IH0gZnJvbSAnLi4vdXRpbHMvc3RyaW5nJztcblxuY29uc3QgUkVMRUFTRV9USU1FT1VUID0gMTAwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyb3dzZXJTZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2Jyb3dzZXJDb25uZWN0aW9uczogQnJvd3NlckNvbm5lY3Rpb25bXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9icm93c2VyRXJyb3JIYW5kbGVyOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3BlbmRpbmdSZWxlYXNlczogUHJvbWlzZTx2b2lkPltdO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX29wdGlvbnM6IEJyb3dzZXJTZXRPcHRpb25zO1xuICAgIHB1YmxpYyBicm93c2VyQ29ubmVjdGlvbkdyb3VwczogQnJvd3NlckNvbm5lY3Rpb25bXVtdO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yIChicm93c2VyQ29ubmVjdGlvbkdyb3VwczogQnJvd3NlckNvbm5lY3Rpb25bXVtdLCBvcHRpb25zOiBCcm93c2VyU2V0T3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZWxlYXNlcyAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMuYnJvd3NlckNvbm5lY3Rpb25Hcm91cHMgID0gYnJvd3NlckNvbm5lY3Rpb25Hcm91cHM7XG4gICAgICAgIHRoaXMuX2Jyb3dzZXJDb25uZWN0aW9ucyAgICAgID0gZmxhdHRlbihicm93c2VyQ29ubmVjdGlvbkdyb3Vwcyk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgICAgICAgICAgICAgICAgID0gb3B0aW9ucztcblxuICAgICAgICB0aGlzLl9icm93c2VyRXJyb3JIYW5kbGVyID0gKGVycm9yOiBFcnJvcikgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcblxuICAgICAgICB0aGlzLl9icm93c2VyQ29ubmVjdGlvbnMuZm9yRWFjaChiYyA9PiBiYy5vbignZXJyb3InLCB0aGlzLl9icm93c2VyRXJyb3JIYW5kbGVyKSk7XG5cbiAgICAgICAgLy8gTk9URTogV2UncmUgc2V0dGluZyBhbiBlbXB0eSBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIE5vZGUga2lsbHMgdGhlIHByb2Nlc3Mgb24gYW4gJ2Vycm9yJyBldmVudFxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBoYW5kbGVyLiBTZWU6IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50c19ldmVudGVtaXR0ZXJcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBub29wKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBfd2FpdElkbGUgKGJjOiBCcm93c2VyQ29ubmVjdGlvbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoYmMuaWRsZSB8fCAhYmMuaXNSZWFkeSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGF3YWl0IHByb21pc2lmeUV2ZW50KGJjLCAnaWRsZScpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGFzeW5jIF9jbG9zZUNvbm5lY3Rpb24gKGJjOiBCcm93c2VyQ29ubmVjdGlvbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoYmMuc3RhdHVzID09PSBCcm93c2VyQ29ubmVjdGlvblN0YXR1cy5jbG9zZWQgfHwgYmMuc3RhdHVzID09PSBCcm93c2VyQ29ubmVjdGlvblN0YXR1cy5jbG9zaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGF3YWl0IGJjLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfd2FpdENvbm5lY3Rpb25PcGVuZWQgKGJjOiBCcm93c2VyQ29ubmVjdGlvbik6IFByb21pc2U8QnJvd3NlckNvbm5lY3Rpb24+IHtcbiAgICAgICAgY29uc3Qgb3BlbmVkVGltZW91dCA9IHRoaXMuX29wdGlvbnMuYnJvd3NlckluaXRUaW1lb3V0IHx8IGF3YWl0IGJjLmdldERlZmF1bHRCcm93c2VySW5pdFRpbWVvdXQoKTtcbiAgICAgICAgY29uc3QgdGltZW91dEVyciAgICA9IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuY2Fubm90RXN0YWJsaXNoQnJvd3NlckNvbm5lY3Rpb24pO1xuICAgICAgICBjb25zdCBvcGVuZWRPckVycm9yID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHByb21pc2lmeUV2ZW50KHRoaXMsICdlcnJvcicpLFxuICAgICAgICAgICAgcHJvbWlzaWZ5RXZlbnQoYmMsICdvcGVuZWQnKVxuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gZ2V0VGltZUxpbWl0ZWRQcm9taXNlKG9wZW5lZE9yRXJyb3IsIG9wZW5lZFRpbWVvdXQsIHsgcmVqZWN0V2l0aDogdGltZW91dEVyciB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF93YWl0Q29ubmVjdGlvbnNPcGVuZWQgKCk6IFByb21pc2U8QnJvd3NlckNvbm5lY3Rpb25bXT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB0aGlzLl9icm93c2VyQ29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGJjID0+IGJjLnN0YXR1cyAhPT0gQnJvd3NlckNvbm5lY3Rpb25TdGF0dXMub3BlbmVkKVxuICAgICAgICAgICAgICAgIC5tYXAobm90T3BlbmVkQ29ubmVjdGlvbiA9PiB0aGlzLl93YWl0Q29ubmVjdGlvbk9wZW5lZChub3RPcGVuZWRDb25uZWN0aW9uKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jaGVja0ZvckRpc2Nvbm5lY3Rpb25zICgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGlzY29ubmVjdGVkVXNlckFnZW50cyA9IHRoaXMuX2Jyb3dzZXJDb25uZWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcihiYyA9PiBiYy5zdGF0dXMgPT09IEJyb3dzZXJDb25uZWN0aW9uU3RhdHVzLmNsb3NlZClcbiAgICAgICAgICAgIC5tYXAoYmMgPT4gYmMudXNlckFnZW50KTtcblxuICAgICAgICBpZiAoZGlzY29ubmVjdGVkVXNlckFnZW50cy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLmNhbm5vdFJ1bkFnYWluc3REaXNjb25uZWN0ZWRCcm93c2VycywgZGlzY29ubmVjdGVkVXNlckFnZW50cy5qb2luKCcsICcpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcHJlcGFyZUNvbm5lY3Rpb25zICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2hlY2tGb3JEaXNjb25uZWN0aW9ucygpO1xuICAgICAgICBhd2FpdCB0aGlzLl93YWl0Q29ubmVjdGlvbnNPcGVuZWQoKTtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBjcmVhdGVzIGFuZCBwcmVwYXJlcyBCcm93c2VyU2V0IGluc3RhbmNlIHdpdGggZ2l2ZW4gYnJvd3NlciBjb25uZWN0aW9uc1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZnJvbSAoYnJvd3NlckNvbm5lY3Rpb25zOiBCcm93c2VyQ29ubmVjdGlvbltdW10sIG9wdHM6IEJyb3dzZXJTZXRPcHRpb25zKTogUHJvbWlzZTxCcm93c2VyU2V0PiB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJTZXQgPSBuZXcgQnJvd3NlclNldChicm93c2VyQ29ubmVjdGlvbnMsIG9wdHMpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlQ29ubmVjdGlvbnMgPSBicm93c2VyU2V0LnByZXBhcmVDb25uZWN0aW9ucygpO1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlclNldEVycm9yICAgID0gcHJvbWlzaWZ5RXZlbnQoYnJvd3NlclNldCwgJ2Vycm9yJyk7XG5cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbIHByZXBhcmVDb25uZWN0aW9ucywgYnJvd3NlclNldEVycm9yIF0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYnJvd3NlclNldDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgZmluYWxFcnJvciA9IGUuY29kZSA9PT0gUlVOVElNRV9FUlJPUlMuY2Fubm90RXN0YWJsaXNoQnJvd3NlckNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICA/IGJyb3dzZXJTZXQuY3JlYXRlQnJvd3NlckNvbm5lY3Rpb25FcnJvcihlKVxuICAgICAgICAgICAgICAgIDogZTtcblxuICAgICAgICAgICAgYXdhaXQgYnJvd3NlclNldC5kaXNwb3NlKCk7XG5cbiAgICAgICAgICAgIHRocm93IGZpbmFsRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlQnJvd3NlckNvbm5lY3Rpb25FcnJvciAoZXJyb3I6IEVycm9yKTogQnJvd3NlckNvbm5lY3Rpb25FcnJvciB7XG4gICAgICAgIGNvbnN0IG5vdE9wZW5lZENvbm5lY3Rpb25zID0gdGhpcy5fYnJvd3NlckNvbm5lY3Rpb25zLmZpbHRlcihiYyA9PiBiYy5zdGF0dXMgIT09IEJyb3dzZXJDb25uZWN0aW9uU3RhdHVzLm9wZW5lZCk7XG5cbiAgICAgICAgY29uc3QgbnVtT2ZBbGxDb25uZWN0aW9ucyAgICAgICA9IHRoaXMuX2Jyb3dzZXJDb25uZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG51bU9mTm90T3BlbmVkQ29ubmVjdGlvbnMgPSBub3RPcGVuZWRDb25uZWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgbGlzdE9mTm90T3BlbmVkQ29ubmVjdGlvbnMgPSBjcmVhdGVMaXN0KG5vdE9wZW5lZENvbm5lY3Rpb25zLm1hcChiYyA9PiBiYy5icm93c2VySW5mby5hbGlhcykpO1xuICAgICAgICBjb25zdCBsaXN0T2ZIaW50cyAgICAgICAgICAgICAgICA9IGNyZWF0ZUxpc3QoZ2V0QnJvd3NlckNvbm5lY3Rpb25IaW50cyh0aGlzLl9icm93c2VyQ29ubmVjdGlvbnMsIHRoaXMuX29wdGlvbnMpKTtcblxuICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXJDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgbnVtT2ZOb3RPcGVuZWRDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIG51bU9mQWxsQ29ubmVjdGlvbnMsXG4gICAgICAgICAgICBsaXN0T2ZOb3RPcGVuZWRDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIGxpc3RPZkhpbnRzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbGVhc2VDb25uZWN0aW9uIChiYzogQnJvd3NlckNvbm5lY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9icm93c2VyQ29ubmVjdGlvbnMuaW5jbHVkZXMoYmMpKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgICAgIHJlbW92ZSh0aGlzLl9icm93c2VyQ29ubmVjdGlvbnMsIGJjKTtcblxuICAgICAgICBiYy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9icm93c2VyRXJyb3JIYW5kbGVyKTtcblxuICAgICAgICBjb25zdCBhcHByb3ByaWF0ZVN0YXRlU3dpdGNoID0gYmMucGVybWFuZW50ID9cbiAgICAgICAgICAgIEJyb3dzZXJTZXQuX3dhaXRJZGxlKGJjKSA6XG4gICAgICAgICAgICBCcm93c2VyU2V0Ll9jbG9zZUNvbm5lY3Rpb24oYmMpO1xuXG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBnZXRUaW1lTGltaXRlZFByb21pc2UoYXBwcm9wcmlhdGVTdGF0ZVN3aXRjaCwgUkVMRUFTRV9USU1FT1VUKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVtb3ZlKHRoaXMuX3BlbmRpbmdSZWxlYXNlcywgcmVsZWFzZSkpIGFzIFByb21pc2U8dm9pZD47XG5cbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbGVhc2VzLnB1c2gocmVsZWFzZSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbGVhc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRpc3Bvc2UgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBOT1RFOiBXaGVuIGJyb3dzZXJDb25uZWN0aW9uIGlzIGNhbmNlbGxlZCwgaXQgaXMgcmVtb3ZlZCBmcm9tXG4gICAgICAgIC8vIHRoZSB0aGlzLmNvbm5lY3Rpb25zIGFycmF5LCB3aGljaCBsZWFkcyB0byBzaGlmdGluZyBpbmRleGVzXG4gICAgICAgIC8vIHRvd2FyZHMgdGhlIGJlZ2lubmluZy4gU28sIHdlIG11c3QgY29weSB0aGUgYXJyYXkgaW4gb3JkZXIgdG8gaXRlcmF0ZSBpdCxcbiAgICAgICAgLy8gb3Igd2UgY2FuIHBlcmZvcm0gaXRlcmF0aW9uIGZyb20gdGhlIGVuZCB0byB0aGUgYmVnaW5uaW5nLlxuICAgICAgICBtYXBSZXZlcnNlKHRoaXMuX2Jyb3dzZXJDb25uZWN0aW9ucywgKGJjOiBCcm93c2VyQ29ubmVjdGlvbikgPT4gdGhpcy5yZWxlYXNlQ29ubmVjdGlvbihiYykpO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX3BlbmRpbmdSZWxlYXNlcyk7XG4gICAgfVxufVxuIl19